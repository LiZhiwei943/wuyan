[{"id":"745fa9d0dd7564f8475d86a8b9ad72f3","title":"java","content":"JAVAjava最早的版本诞生于1995年\n目前长期支持的JDK版本为，8版和11版\njava se    标准类库\njava ee    企业类库\njava的特点\njava是面向对象编程\njava的健壮性，强机制类型、异常处理、垃圾自动回收\n跨平台性，通过 . java编译出的 . class文件可以在mac、window、linux多种平台运行\njava和js一样是一门解释类型语言，需要通过编译器（开发工具）查看结果\n\njava的运行与编译JVM：java虚拟机，java语言通过不同平台的java虚拟机实现java程序的运行\nJDK :java开发工具集  JDK = JRE+开发工具库\nJRE：java运行环境    JRE=JVM+核心类库\n如果不做开发，想直接运行编译好的 . class文件，只需要JVM和JRE即可\njava学习第二天javaJDK下载下载地址：https://www.oracle.com/java/technologies/downloads/#java8\n下载完成后配置环境变量：https://www.jb51.net/article/243119.htm#_lab2_0_0\n我的第一个java程序//public class Hello&#123;&#125;  创建一个共有的class类\npublic class Hello&#123;\n\t\n    //创建入口函数main\n\tpublic static void main(String[] args)&#123;\n        //通过系统输出字符串 \"lzw studying for java\"\n\t\tSystem.out.println(\"lzw studying for java\");\n\t&#125;\n&#125;\n\n具体步骤：https://www.bilibili.com/video/BV1fh411y7R8?p=17&amp;spm_id_from=pageDriver&amp;vd_source=f24cb303eb5accca215fadb0a6729822\n补充.java 源文件    \n.class 字节码文件\n编写java程序注意事项\n文件名与与创建的public主类名需要一致\n每个java文件中，public主类名，有且只能有一个\njava文件只能有一个public主类名，但可以有多个class类名，每个class类名都可以有一个入口main方法\n每行程序必须要以 ；结尾\n\n学习一门语言\n掌握 会使用，能做出东西\n\n能够熟练去使用，实现需求\n\n挑细节，了解其底层原理，逐步深入，改善自己的编码思维\n\n每天都要学习不能中断\n\n\njava转义字符\\t 制表符，固定空格\n\\n 换行符\n因为在编程中，一些符号属于关键符号，无法直接输入，因此需要通过 \\ 来实现\n\\\\     输出    \\\n\\‘    输出 单引号 ‘\n\\”    输出 双引号 “\n\\r  回车    这里的回车是指将光标移动至当前行的最前方，然后根据\\t后面字数替换相对数量字数\n结合使用：\npublic class Hello\n&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//\\t\n\t\tSystem.out.println(\"I\\tLove\\tYou\");\n\t\t//\\r\n\t\tSystem.out.println(\"我是真的废物\\r我啊\");\n\t\t//\\r+\\n\n\t\tSystem.out.println(\"我是真的废物\\r\\n不！我不是。\");\n\t\t//结合使用\n\t\tSystem.out.println(\"书名\\t作者\\t价格\\t销量\\r\\n三国\\t罗贯中\\t120\\t1000\");\n\t&#125;\n&#125;\n\n\n\njava注释添加注释可提高代码的可读性，做到自己看得懂，别人也看得懂\n单行注释： //    \n多行注释： /**/\n文档注释：/**\n​                    *\n​                    * @author XXX    \n​                    */\n文档注释可以通过命令，创建网页形式的工程文档  \njavadoc  -d  文件保存路径\t-author  文件名称\njavadoc -d D:\\桌面\\folder\\java\\temp  -author -version Hello.java\n\n//我是单行注释\n\n/*\n\t我\n\t是\n\t多\n\t行\n\t注释\n*/\n\n//它是文档注释\n/**\n* @author 无言\n* @version 1.0\n*/\n\n注意：\n\n注释不会被编译\n多行注释中不能嵌套多行注释\n文档注释中的  @XXX 是有指定的，不能随便输入\n\njava学习第三天java编写规范\n文档注释只用于java的类与方法\n两个字符之间要有空格  a + b = c\ntab向右退格，shift+tab向左退格  可选多行代码\njava代码编译需要使用utf-8字符集\n以 ；结尾后记住要换行，且每一行代码字数最多不要超过80个\n\n命令行dos命令md D:\\\\文件夹名\t\t\t在D盘根目录下创建文件夹\nrd D:\\\\文件夹名\t\t\t在D盘根目录下删除文件夹\ncls\t\t\t\t\t   清空命令行\ndir\t\t\t\t\t\t查看当前目录有什么内容\ndir 路径\t\t\t\t   查看指定路径下有什么内容\ncd ../\t\t\t\t\t切换到上一级目录\ncd ./\t\t\t\t\t切换到当前目录\ncd /\t\t\t\t\t切换到根目录\nD:\t\t\t\t\t\t切换到D盘，切换到其他盘方法一样\ntree\t\t\t\t\t查看指定文件夹下的文件目录树\nexit\t\t\t\t\t退出命令行\necho ok > www.txt\t\t将ok写入到www.txt文件中，如果txt文件不存在，创建该文件\ndel 文件名\t\t\t\t\t删除文件\ncopy 文件名  D:/文件名\t将指定文件拷贝到指定目录下，目标目录下的文件名可自行设置\nmove 文件名  D:/文件名\t将指定文件剪切到指定目录下，目标目录下的文件名可自行设置\n\n相对路径与绝对路径D盘下有abc和abd两个文件夹\n需求：我想要在abc中访问abd中的文件\n\n相对路径\n从当前目录开始向目标文件进行访问\n../abd/文件名\n\n\n绝对路径\n从顶级目录开始向目标文件进行访问\nD:/abd/文件名\n\n\n\nJava学习第4天输出语句System.out.println() 输出语句并换行\nSystem.out.print() 输出语句不换行\n变量变量是程序的基本组成单位\n用于存储值数据的地址，通过变量存储的地址获取数据并输出\n注意：\n\n变量 = 变量名+值+数据类型\n\n变量在同一作用域中不能重名 \n\n变量值需要符合变量的数据类型\n\n\npublic Hello&#123;\n    public static void main(String[] args)&#123;\n        int num =3; //创建整型变量num存储数字3的地址\n        System.out.println(num);\n    &#125;\n&#125;\n\n数据类型字节（byte）：字节大小等于数据所占空间大小\n基本数据类型：\n\nbyte&gt;short&gt;int&gt;long   1&gt;2&gt;4&gt;8整型\nfloat 浮点  占4个字节的浮点数\ndouble 多重浮点型  占8个字节的浮点数\nchar 字符 ‘a’\nBoolean 布尔值  true false\n\n引用数据类型：\n\n类 class\n接口 interface\n数组 [ ]\nString[] 字符串 “aaaa”\n\n+号使用运算顺序从左至右 \n数字+字符串= 字符串\n数字+数字 = 数字 \n数字+字符 = 数字\n数据类型（Detail）1byte = 8bit\n整型：\n\n在数字后面+”L” or “l” 将数值转换为Long类型\n定义整型时通常使用int类型，不确定大小时使用long\n\n浮点型：\n\n浮点数默认为double类型，声明为float类型需要在后面加 ”f“ 或 ”F“\n10进制数形式表示浮点数：.123 , 678.0f\n科学计数法表示：0.02345e2  or  0.02345E-2   \n通常情况下，浮点数应该使用double表示数据类型\n浮点数2.7 不等于  8.1/3，因为8.1/3 =2.6999999999999997    \n\n字符：\n\n字符可以直接存放数字\n字符必须用单引号包括\n转义字符也是字符\n输出字符对应ASCll码，（int）’a’\n输出ASCll码对应的字符 （char）97\n\n字符编码：\n\nutf-8 大小可变的编码 字母1字节  汉字3字节：\n\nUTF-8是互联网上使用最广的一种Unicode实现方式（改进）\nUTF-8是一种变长的编码方式，它可以使用1-6个字节表示一个字符，根据不同的字符变化长度\n大小可变\n\n\ngbk 可以表示汉字，范围广  字母1字节  汉字2字节\n\ngbk2312  可以表示少量汉字\n\nbig5 可以表示繁体字\n\nASCll编码表：\n\n一个字节可以表示256给字符，ASCll码一共128个字符\n缺点：不能表示所有字符\n\n\nUnicode编码表：\n\n好处：一种编码，包含世界上所有字符编码\n缺点：对应存储空间比较浪费\nUnicode码表兼容ASCll码表\n\n\n\nBoolean类型：\n\n只有两个值：true   false\n不可以用0或者非0代替false或者true\n\nclass typeDetail&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//整数\n\n\t\t//在数字后面+”L\" or \"l\" 将数值转换为Long类型\n\t\t//int n2 = 3L;  //Error：空间超出\n\t\t//定义整型时通常使用int类型，不确定大小时使用long\n\t\tlong num = 2L; \n\t\tSystem.out.println(num);\n\t\t//浮点数\n\n\t\t//浮点数默认为double类型，声明为float类型需要在后面加 ”f“ 或 ”F“\n\t\tdouble f = 0.123f;\n\t\t//浮点数表示方式\n\t\t//十进制表示\n\t\tdouble sf  = .123; // 或者 768.0f\n\t\t//科学计数法表示\n\t\tdouble kf = 0.12345E-2;\n\t\tdouble kf2 = 0.12345e2;\n\t\t\n\t\tSystem.out.println(f);\n\t\tSystem.out.println(sf);\n\t\tSystem.out.println(kf);\n\t\t\n\n\t\t//浮点数陷阱\n\t\t//num1 不等于 num2\n\t\tdouble num1 = 2.7; //2,7\n\t\tdouble num2 = 8.1/3; // 2.6999999999999997\n\t\tSystem.out.println(num1+\"\\n\"+num2);\n\n\t\t//如果需要进行判断，可以通过判断差值的绝对值是否在某一范围内进行判断\n\t\tif(Math.abs(num1-num2)&lt;0.000001)&#123;\n\t\t\tSystem.out.println(\"num1==num2\");\n\t\t&#125;\n\n\n\t\t//字符\n\t\tchar s = 'd';\n\t\t\n\t\t//字符可以存储数字\n\t\tchar s1 = 99;\n\t\t//输出字符对应ASCll码\n\t\tint st = 'a';\n\t\t\n\t\tSystem.out.println(st);\n\t\tSystem.out.println((char)3886);\n\t\t\n\t&#125;\n&#125;\n\n\n\n基本数据类型转换自动转换类型基本转换顺序：\n\nchar-&gt;int-&gt;long-&gt;float-&gt;double\nbyte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double\n\n正确例子：int a = ‘c’； √\n​        double d = 80;  √\n错误例子：\n​    \nclass autoDetail\n&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//转换错误例子\n\t\tint num =23;\n\t\t//当出现浮点数运算时，系统会自动将所有数据转换为最大容量的数据\n\t\t\n\t\t//float f = num + 1.1;//Error 会因此转换为double\n\t\t\n\t\t//解决方法\n\t\tfloat f = num + 1.1F;\n\n\n\t&#125;\n&#125;\n\nDetail：\n\n当出现多种类型的数据混合运算时，系统自动将所有数据转换为最大容量的数据类型后，再进行运算。\n不能将大容量的数据赋值给小容量的数据类型\nbyte和short与char不会出现自动转换\nBoolean不参加转换\n表达式的结果类型自动提升为操作数最大的数据类型\nbyte、short、char、三者可以进行技术，在计算时首先转换为int类型\n表达式结果的类型自动提升为操作数最大的类型\n\n强制转换注意：\n​    \nclass autoDetail\n&#123;\n\tpublic static void main(String[] args)&#123;\n\t\n\t\t//1\n\t\tint a = (int)3.3; //造成精度损失\n\n\t\tint b = 1200;\n\t\tbyte c = (byte)b; //造成数据溢出\n\n\t\t//2\n\t\tint num =3;\n\t\tchar s = num;//error\n\t\tchar s1 = (int)num; //ok\n\n\t\t//3\n\t\tbyte num1 = 3;\n\t\tshort num2 = 4;\n\t\tbyte num3 = num1+num2;//error\n\t\tint num3 = num1+num2;//ok\n\t&#125;\t\n&#125;\n\n​    Detail:\n\n强转符只对最近操作符有效，往往使用小括号提升优先级\nchar类型可以保存int常量值，但不能保存int的变量值，需要强转\nbyte和short类型在进行运算时，当做int类型处理\n\nString类型基本数据类型转String类型\n通过 变量+” “ 进行字符串类型转换\nclass autoDetail\n&#123;\n\tpublic static void main(String[] args)&#123;\n\t\n\t\tint a = 33;\n\n\t\tSystem.out.println(a + \" \");\n\n\t\t\n\t&#125;\t\n&#125;\n\nString类型转基本数据类型\n转int类型： Integer.parseInt(变量)\n转double类型：Double.parseDouble(变量)\n转float类型:Float.parseFloat(变量)\n转long类型：Long.parseLong(变量)\n转byte类型：Byte.parseByte(变量)\n转short类型：Short.parseShort(变量)\n转Boolean类型：Boolean.parseBoolean(变量)\n转char类型：转char需要通过 charAt方法\nclass autoDetail\n&#123;\n\tpublic static void main(String[] args)&#123;\n\t\n\t\tString s = \"123\";\n\t\tint a = Integer.parseInt(s);\n\n\t\tdouble b =Double.parseDouble(s);\n\n\t\tfloat f =Float.parseFloat(s);\n\n\t\tlong e = Long.parseLong(s);\n\n\t\tbyte g = Byte.parseByte(s);\n\n\t\tshort x =Short.parseShort(s);\n \n\t\tboolean r = Boolean.parseBoolean(s);\n\t\t\n\t\tSystem.out.println(s.charAt(0));\n\n\t\t\n\t&#125;\t\n&#125;\n\n注意：字符串如”hello“这种无法转换为整数浮点数之类的\nJava API文档地址链接：https://www.matools.com\n每个API都有类、接口、异常\njava学习第5天算数运算符\n+运算符\n\n-运算符\n\n*运算符\n\n/整除运算符\n\n```javadouble a = 10 / 4; // 2.0\n2. &#96;&#96;&#96;java\n   double a &#x3D; 10.0 &#x2F; 4; &#x2F;&#x2F; 2.5\n\n\n%取余运算符\n\n```javaint a = 10 % 8; //2int b = -10 % 8; //-2\n6. ++自增运算符\n\n   1. 先自增后运算  ++i\n\n   2. 先运算后自增 i++\n\n   3. &#96;&#96;&#96;java\n      int a &#x3D; 1;\n      int b &#x3D; a++;&#x2F;&#x2F;1\n      int c &#x3D; ++a;&#x2F;&#x2F;3\n\n\n–自减运算符\n\n先自减后运算  –i\n\n先运算后自减 i–\n\n```javaint a = 2;int b = a–;//2int c = –a;//0\n\n## 关系运算符（relational）\n\n1. &#x3D;&#x3D;判断相等运算符\n\n   1. &#96;&#96;&#96;java\n      System.out.println(12 &#x3D;&#x3D; 11)&#x2F;&#x2F; false\n\n\n!=判断不等运算符\n\n```javaSystem.out.println(12 != 11)// true\n3. &lt; 小于运算符\n\n   1. &#96;&#96;&#96;java\n      System.out.println(12 &lt; 11)&#x2F;&#x2F; flase\n\n\n&gt; 大于运算符\n\n```javaSystem.out.println(12 &gt; 11)// true\n5. \\&gt;&#x3D; 大于等于运算符\n\n   1. &#96;&#96;&#96;java\n      System.out.println(12 &gt;&#x3D; 11)&#x2F;&#x2F; true\n      System.out.println(12 &gt;&#x3D; 12)&#x2F;&#x2F; true\n\n\n&lt;= 小于等于运算符\n\n```javaSystem.out.println(12 &lt;= 11)// falseSystem.out.println(12 &lt;= 12)// true\n      \n\n## 逻辑运算符          （logic）\n\n1. 与 （两个都为true则为true，其他情况都为false）\n\n   1. 短路与 &amp;&amp; （当第一个条件为false，后面的条件不再进行判断） \n   2. 逻辑与 &amp; （当第一个条件为false，后面的条件还会进行判断）\n\n   \n\n2. 或 （有一个为true则为true,只有都为false时才为false）\n\n   1. 短路或 ||（当第一个条件为true，后面的条件不再进行判断）\n\n   2. 逻辑或 |（当第一个条件为true，后面的条件还会进行判断）\n\n   3. 逻辑异或 ^（两边不同为true，两边相同为false）\n\n      1. &#96;&#96;&#96;java \n         boolean a &#x3D; (10 &gt; 3) ^ (3 &gt; 5);&#x2F;&#x2F;true\n         \n         boolean b &#x3D; (10 &gt; 3) ^ (3 &gt; 1);&#x2F;&#x2F;false\n\n\n\n\n非 ！（真变假，假变真）\n\n```javaboolean a = false;System.out.println(!a);//trueSystem.out.println(!!a);//false\n      \n\n## 复合赋值运算符\n\n**特点：**\n\n1. 复合运算符会进行类型转换\n\n   1. &#96;&#96;&#96;java\n      int a &#x3D; 3;\n      a+&#x3D;4;\n\n\n运算顺序从左至右\n\nint a = 3；a+=3；等价于 a=a+3;\n\n赋值运算符的左边只能是变量，右边 可以是变量、表达式、常量值\n\n\n种类：\n\n+=   复合加  \n\n```javaint a = 10;a+=1;//a = a+1;//其他与之类似\n2. -&#x3D; 复合减\n\n3. *&#x3D; 复合乘\n\n4. &#x2F;&#x3D; 复合除\n\n5. %&#x3D; 复合取模\n\n## 三元运算符     （Temary）\n\n&#96;&#96;&#96;java\nint a &#x3D; 10;\nint b &#x3D;5;\nint resublt &#x3D; a&gt;b?a:b;\n&#x2F;&#x2F;类似于if语句，如果a&gt;b返回true则等于a，否则等于b\n\n\n\nDetail：\n\n三元运算符的结果可以赋值给接收变量的类型（会自动转换）\n\n运算符优先级\n\n()  ,  { } 等\n单目运行 ++ –\n算术运算符\n位移运算符\n比较运算符\n逻辑运算符\n三元运算符\n赋值运算符\n\n标识符命名规则与规范对各种变量，方法，类，函数，凡是自己起的名字都叫标识符 int num = 3；\n标识符命名规则：\n\n由26个英文字母大小写组成，1-9，_ 或者 $符号组成\n标识符不能以数字开头\n标识符名称不可以是保留字或者关键字\n标识符严格区分大小写，命名长度无限制\n标识符命名两个字母之间不能包含空格\n\n标识符命名规范：\n\n尽量用英文或组合英文命名，做到见名知意\n\n包名：多单词组成，所有字母都小写，单词之间用 . 拼接    例 aaa.bbb.ccc\n\n变量名，方法名，多单词组成时从第二个单词开始首字母大写  例 iLoveYou\n\n常量名 所有字母都大写，单词之间用_分割 例 AAA_BBB_CCC\n\n类名，所有单词组合，每个单词首字母都大写  例 MoveClick\n\n\njava学习第6天键盘输入（Scanner）import java.util.Scanner;//引入包\n\npublic class HelloScanner\n&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//创建Scanner对象,设置输入方式为键盘输入\n\t\tScanner myScanner = new Scanner(System.in);\n\t\t//输入姓名\n\t\tSystem.out.println(\"请输入名字\");\n\t\tString name = myScanner.next();\n\t\n\t\t//输入年龄,只能输入int类型的数据\n\t\tSystem.out.println(\"请输入年龄\");\n\t\tint age = myScanner.nextInt();\n\t\t\n\t\t//输入薪资，设置只能输入double类型数据\n\t\tSystem.out.println(\"请输入薪资\");\n\t\tdouble salary = myScanner.nextDouble();\n\n\t\t//展示\n\t\tSystem.out.println(\"name=\"+name+\" gae=\"+age+\" salary=\"+salary);\n\t&#125;\n&#125;\n\n后期不常用，只在前期做测试用\n进制四种进制数\n2进制数（BIN），满二进一，0d+数字表示\n10进制（DEC）；满十进一，日常用进制数，直接数字表示\n8进制（OCT）；满八进一，0+数字 表示\n16进制（HEX）； 满十六进一，从9开始为A、B、C、D、E、F来表示10到15，0x+数字表示\n\n进制的基本转换其他进制转十进制\n二进制转十进制\n从最低位开始（右边）将每个位上的数提取出来并乘以2的（位数-1）次方并与之后以此求出的数相加\n例：01001001  =&gt;1*2(1-1次方)+1*2(4-1次方)+1*2(7-1次方) =1+8+64 \n\n\n八进制转十进制\n从最低位开始（右边）将每个位上的数提取出来并乘以8的（位数-1）次方并与之后以此求出的数相加\n例：01234 =&gt;4*8^0+3*8^1+2*8^2+1*8^3\n\n\n十六进制转十进制\n从最低位开始（右边）将每个位上的数提取出来并乘以16的（位数-1）次方并与之后以此求出的数相加\n例：01A =&gt;10*16^0 + 1*16^1\n\n\n\n十进制转其他进制\n十进制转二进制\n该数不断除以2，直到商为0为止，最后将每步余数倒过来，不够8位左边补0即可\n23 =&gt;`00010111\n操作如下图所示（其他转换以此类推）：\n\n\n十进制转八进制\n该数不断除以8，直到商为0为止，最后将每步余数倒过来，不够8位左边补0即可\n27 =&gt; 00000033\n\n\n十进制转16进制\n该数不断除以16，直到商为0为止，最后将每步余数倒过来，不够8位左边补0即可\n33 =&gt; 21\n\n\n\n二进制转其他进制\n二进制转八进制\n从低位开始，将二进制每三位分为一组转换为对应的八进制数就好了\n0b11001101 =&gt; 11/001/101 =&gt; 3/1/5 =&gt; 0315 =&gt;205 \n\n\n二进制转十六进制\n从低位开始，将二进制每四位分为一组转换为对应的八进制数就好了\n0b11001101 =&gt; 1100/1101 =&gt; C/D =&gt;205\n\n\n\n八进制、十六进制转二进制\n八进制转二进制\n将八进制数每一位转为对应的三位二进制数，逆推总会吧\n0315 =&gt; 3(011)1(001)5(101) =&gt; 011001101 =&gt;205\n\n\n十六进制转二进制\n将十六进制数每一位转为对应的四位二进制数，逆推总会吧\n0xCD =&gt; C(1100) D(1101) =&gt;11001101 =&gt;205\n\n\n\n原码、反码、补码\n二进制的最高位是符号为：0表示正数，1表示负数\n正数的原码、反码、补码都一样（三码合一）\n负数的反码 = 其原码符号位不变其他位取反，1-&gt;0  ,  0 -&gt; 1\n负数的补码 = 其反码+1 ， 负数的反码 = 负数的补码 -1\n0的反码，补码都是0\nJava没有无符号位，Java的数都是有符号的\n计算机都是以补码的形式来运算的\n当我们看运算结果时候，要看它的原码（重点）\n\n位运算符\n按位与 &amp;\n\n两位全为1，结果为1，否则为0\n\n```java//示例+计算机求解过程//获取3的原码  00000000 00000000 00000000 00000011//获取4的原码  00000000 00000000 00000000 00000100//符号为是0，正数三码一体，直接按位或//按位或后的原码 00000000 00000000 00000000 00000000  结果为0System.out.println(3&amp;4);//0\n\n      \n\n2. 按位或 |\n\n   1. 两位有一位为1，则为1，否则为0\n\n   2. &#96;&#96;&#96;java\n      \t\t&#x2F;&#x2F;示例+计算机求解过程\n         \t\t&#x2F;&#x2F;获取2的原码  00000000 00000000 00000000 00000010\n         \t\t&#x2F;&#x2F;获取3的原码  00000000 00000000 00000000 00000011\n         \t\t&#x2F;&#x2F;符号位为0，三码一体\n         \t\t&#x2F;&#x2F;按位或运算   00000000 00000000 00000000 00000011\n         \t\tSystem.out.println(2|3);&#x2F;&#x2F;3\n\n\n按位异或 ^\n\n两位一个为0，一个为1，结果为1，否则为0\n\n```java\n    //示例+计算机求解过程\n       //获取2的原码  00000000 00000000 00000000 00000010\n       //获取3的原码  00000000 00000000 00000000 00000011\n       //符号位为0，三码一体\n       //按位异或运算   00000000 00000000 00000000 00000001\n       System.out.println(2^3);//1\n\n\n4. 按位取反 ~\n\n   1. 1-&gt;0  0-&gt;1\n\n   2. &#96;&#96;&#96;java\n      \t\t&#x2F;&#x2F;示例+计算机求解过程\n         \t\t&#x2F;&#x2F;获取原码 10000000 00000000 00000000 00000011\n         \t\t&#x2F;&#x2F;获取反码 11111111 11111111 11111111 11111100 反码等于原码取反，符号位不变\n         \t\t&#x2F;&#x2F;通过反码获取补码 11111111 11111111 11111111 11111101 补码等于反码+1\n         \t\t&#x2F;&#x2F;通过按位取反运算 00000000 00000000 00000000 00000010\n         \t\tSystem.out.println(~-3);&#x2F;&#x2F;因为正数三码一体，所以结果为2\n```java\n    //获取原码 00000000 00000000 00000000 00000011\n       //因为正数三码一体，直接按位取反运算 11111111 11111111 11111111 11111100\n       //获取取反后的原码 补码-1等于反码，获取反码 11111111 11111111 11111111 11111011\n       //反码取反获取原码 10000000 00000000 00000000 00000100\n       System.out.println(~3);//结果为-4\n\n\n5. 算术右移  &gt;&gt;  ： 低位溢出，符号位不变， 并用符号位补溢出的高位\n\n6. 算术左移 &lt;&lt;   :    符号位不变，低位补0\n\n7. 逻辑右移 \\&gt;&gt;&gt;，又叫无符号右移，低位溢出，高位补0，符号位跟随移动\n\n8. 注意：没有逻辑左移 \\&lt;&lt;&lt;\n\n9. &#96;&#96;&#96;java\n   \t\tint a &#x3D; 1&gt;&gt;2;&#x2F;&#x2F;  00000001 -&gt; 00000000 -&gt; 1&#x2F;2&#x2F;2 结果为0 \n      \t\tint b &#x3D; -1&gt;&gt;2;&#x2F;&#x2F;  00000001 -&gt; 先求反码 11111110 -&gt;再求补码 -&gt; 11111111 -&gt;右位移 11111111 取反码转原码 -&gt; 11111110 -&gt; 00000001 -&gt; -1  \n      \t\tint c &#x3D; 1&lt;&lt;2; &#x2F;&#x2F; 00000001 -&gt; 00000100 -&gt; 1*2*2 结果为 4\n      \t\tint d &#x3D; -1&lt;&lt;2;&#x2F;&#x2F; 10000001 -&gt; 先求反码 11111110 -&gt;再求补码 -&gt; 11111111 -&gt;左位移 11111100 取反码转原码 -&gt; 11111011 -&gt; 00000100 -&gt; -4  \n      \t\tint e &#x3D; 3&gt;&gt;&gt;2; &#x2F;&#x2F; 00000011 -&gt; 00000000 -&gt; 3&#x2F;2&#x2F;2 结果为0\n      \t\tint f &#x3D; -3&gt;&gt;&gt;2; &#x2F;&#x2F;现在的我，明白为什么，希望以后的我也明白  结果为 1073741823\n      \t\tSystem.out.println(a+&quot;,&quot;+b+&quot;,&quot;+c+&quot;,&quot;+d+&quot;,&quot;+e+&quot;,&quot;+f+&quot;,&quot;);\n\nJava学习第七(八)天顺序控制程序从上到下的执行，中间没有任何的判断和跳转\n形式：\nint num = 3;\nint num1 = num-2;\n\n分支语句（if-else）\n\n单分支语句​        if（条件表达式）{\n​                执行语句块1\n}else{\n​            执行语句块2    \n}\n​        当条件表达式为true时会执行语句块1中的代码，如果语句块中只有一条语句可以省略{ }\n​        当条件语句为false时会执行语句块2中的代码，如果没有else，则跳过\nimport java.util.Scanner;\nclass If01 \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\t\n\t\tScanner Sc = new Scanner(System.in);\n\t\tint num = Sc.nextInt();\n\t\tif (num>=18)\n\t\t&#123;\n\t\t\tSystem.out.println(\"你的年龄已经大于18要对自己负责\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"还是个孩子？把你家长叫来！\");\n        &#125;\n\t&#125;\n&#125;\n\n\n多分支语句if（条件表达式1）{\n​                执行语句块1\n}else if(条件表达式2){\n​            执行语句块2    \n}else if(条件表达式3){\n​            执行语句块3    \n}else …if(条件表达式n){\n​        执行语句块n\n}else{\n​        执行语句块n+1\n}\n当条件表达式1不符合时会往后执行，其他条件表达式如果都不符合则执行else中的代码块语句\n注：多分支语句可以没有else，如果所有语句都不支持且没有else，则跳过所有语句。注意只能有一个执行入口（所有分支语句只有一个会执行或者全部不执行直接执行else）\n//来猜猜它会输出什么\nclass If03 \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tBoolean b = true;\n\t\tif(b==false)&#123;\n\t\t\tSystem.out.println(\"a\");\n\t\t&#125;else if(b)&#123;\n\t\t\tSystem.out.println(\"b\");\n\t\t&#125;else if(!b)&#123;\n\t\t\tSystem.out.println(\"c\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"d\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n嵌套语句if(){\n​    if(){\n​        \n​    }else{\n​    \n​    }\n}\n嵌套实例：\nimport java.util.Scanner;\n\nclass  If04\n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tScanner myScanner = new Scanner(System.in);\n\n\t\t\n\t\t//分数系统\n\t\t\n\t\t/*int source = myScanner.nextInt();\n\n\t\tif(60&lt;=source &amp;&amp; source&lt;=100)&#123;\n\t\t\tif(90&lt;=source &amp; &amp;source&lt;=100)&#123;\n\t\t\t\tSystem.out.println(\"A\");\n\t\t\t&#125;else if(80&lt;=source &amp;&amp; source&lt;90)&#123;\n\t\t\t\tSystem.out.println(\"B\");\n\t\t\t&#125;else if(70&lt;=source &amp;&amp; source&lt;80)&#123;\n\t\t\t\tSystem.out.println(\"C\");\n\t\t\t&#125;else if(60&lt;=source &amp;&amp; source&lt;70)&#123;\n\t\t\t\tSystem.out.println(\"D\");\n\t\t\t&#125;\n\t\t&#125;else if(source&lt;60)&#123;\n\t\t\tSystem.out.println(\"为什么没及格呢？\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"输入有误！\");\t\n\t\t&#125;*/\n\n\t\t//旅游系统\n\t\tSystem.out.println(\"请输入年龄\");\n\t\tint age = myScanner.nextInt();\n\t\tSystem.out.println(\"请输入月份\");\n\t\tint month = myScanner.nextInt();\n\t\tif(month >= 4 &amp;&amp; month &lt;=10)&#123;\n\t\t\tif(age>=18 &amp;&amp; age&lt;=60)&#123;\n\t\t\t\tSystem.out.println(\"您的票价为60元\");\n\t\t\t&#125;else if(age&lt;18)&#123;\n\t\t\t\tSystem.out.println(\"您的票价为30元\");\n\t\t\t&#125;else if(age>60)&#123;\n\t\t\t\tSystem.out.println(\"您的票价为20元\");\n\t\t\t&#125;else&#123;\n\t\t\t\tSystem.out.println(\"您的输入有误\");\n\t\t\t&#125;\n\t\t&#125;else if(month>12)&#123;\n\t\t\tSystem.out.println(\"输入有误\");\n\t\t&#125;else&#123;\n\t\t\tif(age>=18 &amp;&amp; age&lt;=60)&#123;\n\t\t\t\tSystem.out.println(\"您的票价为40元\");\n\t\t\t&#125;else if(age&lt;18)&#123;\n\t\t\t\tSystem.out.println(\"您的票价为20元\");\n\t\t\t&#125;else if(age>60)&#123;\n\t\t\t\tSystem.out.println(\"您的票价为20元\");\n\t\t\t&#125;else&#123;\n\t\t\t\tSystem.out.println(\"您的输入有误\");\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nswitch语句switch(表达式){\n​    case 常量1：\n​        执行语句1；\n​        break；\n​    case 常量2：\n​        执行语句2；\n​        break；\n​    case 常量3：\n​        执行语句3；\n​        break；\n​    case 常量n：\n​        执行语句n；\n​        break；\n​    default：\n​        执行语句；\n​        break；\n}\n注解：\n\n通过判断表达式的结果是否等于常量进行语句执行，如果表达式等于case的常量则执行下面的语句，如果不等于，则跳到下一个case与常量进行比较，最终输出结果\n如果case中的常量都不匹配，则会执行default中的语句，default是可选的，同时里面的break语句也是可选的。\ncase中的break语句不能删除，如果删除会出现穿透的效果\n\n示例：\nimport java.util.Scanner;\n\nclass Switch01 \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tScanner myScanner = new Scanner(System.in);\n\n\t\tSystem.out.println(\"请输入对应字母\");\n\t\n\t\t\n\t\tString letter = myScanner.next().charAt(0);\n\t\t\n\n\t\tswitch(letter)&#123;\n\t\t\t\n\t\t\tcase 'a':\n\t\t\t\tSystem.out.println(\"A\");\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tSystem.out.println(\"B\");\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tSystem.out.println(\"C\");\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tSystem.out.println(\"D\");\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tSystem.out.println(\"E\");\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tSystem.out.println(\"F\");\n\t\t\t\tbreak;\t\n\t\t\tcase 'g':\n\t\t\t\tSystem.out.println(\"G\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"other\");\n\t\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n注意：\n\n常量的数据类型需要与表达式类型相同，或者常量与表达式之间的数据类型可以自动转换\ncase中的常量不可以与变量发现任何运算关系，即常量不能是变量，同时常量无法使用比较运算符\n表达式的类型必须是（byte、short、int、char、enum（枚举）、String）这六种，常量类型需与之匹配\n\n穿透的使用import java.util.Scanner;\n\nclass Switch03 \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tScanner myScanner = new Scanner(System.in);\n\n\t\tSystem.out.println(\"请输入对应月份\");\n\t\n\t\t\n\t\tint month = myScanner.nextInt();\n\t\t\t\n\t\tswitch(month)&#123;\n\t\t\t\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"春季\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\t\tSystem.out.println(\"夏季\");\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\t\tSystem.out.println(\"秋季\");\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(\"冬季\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"输入有误\");\n\t\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nif和switch的使用选择\n出现多Boolean类型或者运算范围较大的情况下，建议使用if语句\n出现多选择性且数据类型在 （byte、short、int、char、enum（枚举）、String）这六种数据类型中，可以使用switch\n\njava学习第九天for循环控制语句for（循环变量初始化；循环条件；循环变量迭代）{\n​    循环操作（可以多条语句）；\n}\n注解：\n\nfor关键字，表示循环控制\nfor循环的四个要素：循环变量初始化、循环条件、循环变量迭代、循环操作\nfor循环{}内可以有多条语句，也就是我们要循环操作多次的语句\nfor循环中如果只有一条需要操作的语句，可以省略{}但不建议省略\n\n示例：\nclass  For01\n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tfor(int i =1;i&lt;=10;i++)&#123;\n\t\t\tSystem.out.println(\"Hello World!\");\t\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nDetail\n循环条件返回的是一个Boolean值，为true进行循环，为false时停止循环\n\nfor循环中变量初始化和变量迭代可以写在其他地方，但两边分号；不能省\n\n```javascriptclass  For01{public static void main(String[] args) \n&#123;    int i =1；\n    for( ; i&lt;=10; ; )&#123;\n        System.out.println(&quot;Hello World!&quot;);    \n        i++;\n    &#125;\n&#125;\n\n}\n3. 循环初始值可以有多个，但要求数据类型相同且中间需要通过逗号，隔开，循环变量迭代也可以多个，中间用，隔开\n\n   1. &#96;&#96;&#96;java\n      class  For01\n      &#123;\n      \tpublic static void main(String[] args) \n      \t&#123;\n      \t\tfor(int i &#x3D;1,j &#x3D; 0;i&lt;&#x3D;10;i++,j++)&#123;\n      \t\t\tSystem.out.println(&quot;j&#x3D;&quot;+j+&quot;i&#x3D;&quot;+i);\t\n      \t\t&#125;\n      \t&#125;\n      &#125;\n      \n\n\n\nfor循环与if语句运算符的结合class For02\n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\t\n\t\tint sum =0;\n\t\tfor (int i =1;i&lt;=100;i++)\n\t\t&#123;\n\t\t\tsum+=i;\n\t\t\tif(i%9==0)&#123;\n\t\t\t\tSystem.out.println(i+\"\\n\");\n\t\t\t&#125;\n\t\t&#125;\n\t\tSystem.out.println(\"sum=\"+sum+\"\\n\");\n\n\t&#125;\n&#125;\n\n\nfor循环自增与自减结合class  For03\n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tfor(int i =0,j=5;i&lt;=5;i++,j--)&#123;\n\t\t\tint sum = i+j;\n\t\t\tSystem.out.println(i +\" + \"+ j  +\"= \"+sum);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nWhile循环循环变量初始化；\nWhile（循环条件）{\n​    循环体（语句）\n​    循环变量迭代；\n}\n注意事项:\n\n循环条件是返回一个布尔值的表达式\nwhile循环是先判断后执行，for循环是先执行后判断\n\n示例：\n​    \nclass While \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\t//打印1-100之间能被3整除的数\n\t\tint i = 1;\n\t\twhile(i&lt;=100)&#123;\n\t\t\tif(i%3==0)&#123;\n\t\t\t\tSystem.out.println(i);\n\t\t\t&#125;\n\n\t\t\ti++;\n\t\t&#125;\n\n\t\t//打印40-200之间的偶数\n\t\tint start = 40;\n\t\tint end = 200;\n\t\tSystem.out.println(\"\\n\\n\\n\\n\\n\\n\\n-----------------------------\\n\");\n\t\twhile(start&lt;=end)&#123;\n\t\t\t\n\t\t\tif(start%2==0)&#123;\n\t\t\t\tSystem.out.println(start);\n\t\t\t&#125;\n\n\t\t\tstart++;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\ndo。。。while循环循环变量初始化；\ndo{\n​    循环体（语句）；\n​    循环变量（迭代）；\n}while（循环条件）；\n注解说明：\n\ndo while是关键字\n也有循环四要素但位置不一样\ndowhile循环是先执行后判断，无论如何都会执行一遍\n最后while那要加；\n\n示例代码：\n\n```java//do while与if结合求1-200间能被5整除但不能被三整除的数的个数class Dowhile01{public static void main(String[] args) \n&#123;\n    int start = 1;\n    int end = 200;\n    int count = 0;\n    do&#123;\n        if(start%5==0 &amp;&amp; start%3!=0)&#123;\n            count++;\n            System.out.println(start);\n        &#125;\n        start++;\n    &#125;while(start&lt;=end);\n    \n    System.out.println(&quot;一共有&quot;+count+&quot;个&quot;);\n\n&#125;\n\n}\n2. &#96;&#96;&#96;java\n   import java.util.Scanner;\n   class Dowhile02 \n   &#123;\n   \tpublic static void main(String[] args)&#123;\n   \t\tScanner myScanner &#x3D; new Scanner(System.in);\n   \t\tString str1;\n   \t\tdo&#123;\n   \t\t\tSystem.out.println(&quot;老王还不还钱？ y&#x2F;n&quot;);\n   \t\t\tstr1 &#x3D; myScanner.next();\n   \t\t&#125;while(str1.charAt(0)&#x3D;&#x3D;&#39;n&#39;);\t\n   \t&#125;\n   &#125;\n   \n\n多重循环控制\n将一个循环放在另一个循环内，就形成了嵌套循环，其中for、while、do..while都可以做外层循环或者内层循环（建议最多两层，不要超过三层，不然会使可读性变差）\n\n实质上，多重循环就是把内层循环当做外层循环的循环体，当内层循环为false时结束时当前内层循环返回外层循环，如果外层循环没有结束，则再次进行内层循环。\n简单来说，外层循环，循环几次，就会创建几个内层循环。\n\n\n示例输出九九乘法表：\nclass Fors01 \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\t\n\t\tint num =0;\n\t\tfor(int i =1;i&lt;10;i++)&#123;\n\t\t\tfor(int j = 1;j&lt;=i;j++)&#123;\n\t\t\t\tnum = i*j;\n\t\t\t\tSystem.out.print(j+\" x \"+i+\" = \"+num+\"\\t\");\n\t\t\t&#125;\n\t\t\t\tSystem.out.print(\"\\n\");\n\n\t\t&#125;\n\t&#125;\n&#125;\n\n\njava学习第10天跳转控制语句 breakbreak：停止（跳出）当前循环\n\n不使用标签\n\n//当i == 5时停止循环，输出0，1，2，3，4\nclass Break \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tfor(int i =0;i&lt;10;i++)&#123;\n\t\t\tif(i==5)&#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n            System.out.println(i);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n使用标签\n\n&#x2F;&#x2F;2.输出五遍0，1，2，3，4\n\t\tabc1:\n\t\tfor(int j &#x3D;0;j&lt;10;j++)&#123;\n\n\t\t\tabc2:\n\t\t\t\tfor(int k&#x3D;0;k&lt;5;k++)&#123;\n\t\t\t\t\t\n\t\t\t\t\tif(j&#x3D;&#x3D;5)&#123;\n\t\t\t\t\t\tbreak abc1;\n\t\t\t\t\t&#125;\t\t\t\n\t\t\t\t\tSystem.out.println(k);\n\t\t\t&#125;\n\t\t&#125;\n\nDetail\nbreak语句可以指定退出哪一层\nlabel是标签由程序员指定\nbreak指定到哪个label就停止哪个语句\n在实际开发中尽量不要使用\n如果没有指定label默认退出最近循环体\n登录系统（练习）\n\nimport java.util.Scanner;\nclass Break01\n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tScanner myScanner = new Scanner(System.in);\n\t\tint i =0;\n\t\tString name =\"\";\n\t\tString password = \"\";\n\t\tfor(;i&lt;3;i++)&#123;\n\t\t\tSystem.out.print(\"请输入账号:\\t\");\n\t\t\tname = myScanner.next();\n\t\t\tSystem.out.print(\"请输入密码:\\t\");\n\t\t\tpassword = myScanner.next();\n\t\t\t//补充,变量名.equals(object) 判断当前变量值是否等于object,比较函数\n\t\t\t//推荐使用 object.equals(变量) 推荐使用这种，可以避免空指针\n\t\t\tif(\"丁真\".equals(name) &amp;&amp; \"666\".equals(password))&#123;\n\t\t\t\tSystem.out.println(\"登陆成功\");\n\t\t\t\tbreak;\n\t\t\t&#125;else&#123;\n\t\t\t\tSystem.out.println(\"密码或者账号输入错误,你还有\"+(3-(i+1))+\"次机会\");\n\t\t\t\t\n\t\t\t&#125;\n\t\t&#125;\n\t\tif(i==3)&#123;\n\t\t\tSystem.out.println(\"超过三次错误\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nContinuecontinue 与break使用方法相同，作用为跳过本次循环，而不是停止\n//当i == 5时停止循环，输出0，1，2，3，4，6，7，8，9\nclass Break \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tfor(int i =0;i&lt;10;i++)&#123;\n\t\t\tif(i==5)&#123;\n\t\t\t\tcontinue;\n\t\t\t&#125;\n            System.out.println(i);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nreturn跳出当前方法，在后面学习方法时使用\n在main中使用表示退出程序\n数组 Array数组属于引用数据类型，即：数组就是一组同一类型的数据\n数组可以通过索引进行遍历与获取，数组的索引是从0开始的\n标识符   [ ]\ndouble[] hens = &#123;1,2,3,4.5,6.7,8.9&#125;;//double类型的数组\n\n数组遍历\nfor(int i =0;i&lt;6;i++)&#123;\n\tSystem.out.println(hens[i]);\n&#125;\n\n数组的三种使用方式\n数据类型[ ] 数组名 = new 数据类型[ ]  ===》 int[ ] a = new int[ 5 ]\n\n赋值方式：\nint[] a = new int[3];\n//静态赋值\nint[0] = 1;\nint[1] = 2;\nint[2] = 3;\n//动态赋值\nfor(int i =0;i&lt;3;i++)&#123;\n    a[i] =i;\n&#125;\n\n\n先声明  int[ ]  a ; 或者  int a[ ] ;     再创建 a = new int[10]\n\n赋值方式\nint[] a;\na = [10];\n\n\n静态初始化\n\n赋值方式\nint[] a  = &#123;1,2,3,4,5,6,7,8&#125;;\n\n\n\n注意事项与Detail\n数据是多个相同类型数据的组合，包含会进行数据类型自动转换的数据\n数组中的元素可以放任何数据类型，包含基本类型和引用类型，不能混用\n数组创建后如果没有赋值，会拥有默认值，byte，short，int，long是0，float，double是0.0，char是\\u0000，String是null,Boolean是fa’l’se\n数组下标是从0开始的\n数组下标必须在指定范围内的，超出范围会报错：下标越界异常\n数组是一个引用类型，属于对象\n\n数组赋值 Assignclass ArrayAssign \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\t//基本数据类型赋值，赋值方式为值拷贝\n\t\tint n1 =10;\n\t\tint n2 =n1;\n\n\t\tn2 = 1;\n\t\tSystem.out.println(\"n1=\"+n1);//10\n\t\tSystem.out.println(\"n2=\"+n2);//1\n\n\t\t//数组中默认情况下属于引用传递，赋的值是地址，赋值方式为引用传递\n\t\t//因为共用一个地址，arr2的变化会影响到arr1\n\t\tint[] arr1 = &#123;1,2,3,5&#125;;\n\t\tint[] arr2 = arr1;\n\n\t\tarr2[0] =10;\n\t\tSystem.out.println(arr1[0]);//10\n\t&#125;\n&#125;\n\n\n数组的拷贝\nclass ArrayAssign \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tint[] num1 =&#123;1,2,3,4,5&#125;;\n\t\tint[] num2 = new int[num1.length];\n\n\t\tfor(int i =0;i&lt;num1.length;i++)&#123;\n\t\t\tnum2[i] = num1[i];\n\t\t&#125;\n\t\tnum2[0] = 10;\n\t\tSystem.out.println(num1[0]);//1\n\t\tSystem.out.println(num2[0]);//10\n\n\t&#125;\n&#125;\n\n\n数组的反转\n\n```javaclass ArrayAssign{public static void main(String[] args) \n&#123;\n    int[] num1 =&#123;1,2,3,4,5&#125;;\n    int[] num2 = new int[num1.length];\n\n    for(int i =num1.length-1,j=0;i&gt;=0;i--,j++)&#123;\n        num2[j] = num1[i];\n    &#125;\n    for(int k=0;k&lt;num2.length;k++)&#123;\n        System.out.print(num2[k]);\n    &#125;\n\n&#125;\n\n}\n2. &#96;&#96;&#96;java\n   class ArrayAssign \n   &#123;\n   \tpublic static void main(String[] args) \n   \t&#123;\n   \t\tint[] num1 &#x3D;&#123;1,2,3,4,5&#125;;\n   \t\tint len &#x3D; num1.length;\n   \t\tfor(int i &#x3D;0;i&lt;len&#x2F;2;i++)&#123;\n   \t\t\tint temp &#x3D; num1[len-1-i];\n   \t\t\tnum1[len-1-i]&#x3D; num1[i];\n   \t\t\tnum1[i] &#x3D; temp;\n   \t\t&#125;\n   \t\tfor(int j &#x3D;0;j&lt;len;j++)&#123;\n   \t\t\tSystem.out.print(num1[j]);\n   \t\t&#125;\n   \t&#125;\n   &#125;\n   \n\n数组扩展，添加import java.util.Scanner;\nclass ArrayAdd \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tScanner myScanner = new Scanner(System.in);\n\t\tint[] arr =&#123;1,2,3,4&#125;;\n\t\tString h;\n\t\tint num;\n\t\twhile(true)&#123;\n\t\t\tint[] arr1 = new int[arr.length+1];\n\t\t\tfor(int i=0;i&lt;arr.length;i++)&#123;\n\t\t\t\tarr1[i] = arr[i];\n\t\t\t&#125;\n\t\t\tSystem.out.println(\"请输入要添加的数\");\n\t\t\tnum = myScanner.nextInt();\n\t\t\tarr1[arr1.length-1]=num;\n\t\t\tarr = arr1;\n\t\t\t\n\n\t\t\tSystem.out.println(\"还要添加吗？y/n\");\n\t\t\t h= myScanner.next();\n\t\t\tif(h.charAt(0)=='y')&#123;\n\t\t\t\tcontinue;\n\t\t\t&#125;else if(h.charAt(0)=='n')&#123;\n\t\t\t\tbreak;\n\t\t\t&#125;else&#123;\n\t\t\t\tSystem.out.println(\"无效输入\");\n\n\t\t\t&#125;\n\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n数组缩减import java.util.Scanner;\nclass ArrayReduce \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tScanner myScanner = new Scanner(System.in);\n\t\tint[] arr =&#123;1,2,3,4&#125;;\n\t\tString h;\n\t\tint num;\n\t\tdo&#123;\n\t\t\tif(arr.length&lt;2)&#123;\n\t\t\t\tbreak;\n\t\t\t&#125;else&#123;\n\t\t\t\tint[] arr1 = new int[arr.length-1];\n\t\t\t\tfor(int i=0;i&lt;arr1.length;i++)&#123;\n\t\t\t\tarr1[i] = arr[i];\n\t\t\t\t&#125;\n\t\t\t\tarr = arr1;\n\t\t\t&#125;\n\t\t\n\t\t\tSystem.out.println(\"缩减完成！\");\n\t\t\tSystem.out.println(\"还要缩减吗？y/n\");\n\t\t\t h= myScanner.next();\n\t\t\tif(h.charAt(0)=='y')&#123;\n\t\t\t\tcontinue;\n\t\t\t&#125;else if(h.charAt(0)=='n')&#123;\n\t\t\t\tbreak;\n\t\t\t&#125;else&#123;\n\t\t\t\tSystem.out.println(\"无效输入\");\n\n\t\t\t&#125;\n\t\t\t\n\t\t&#125;while(true);\n\n\t&#125;\n&#125;\n\n\n排序将多个数据按指定顺序排序\n冒泡排序：存在n个元素则需要进行n-1轮比较，n-1轮可以看作外层循环，在每一轮确定一个最大数并放在最后，以此类推，比较时如果前面的数比后面的数大就交换位置，如果没有就以大的数做比较数进行比较，代码实现：\n\nint[] arr =&#123;2,1,4,3&#125;;\nfor(int i =0;i&lt;arr.length;i++)&#123;\n\t\t\tfor(int j =0;j&lt;arr.length-1-i;j++)&#123;\n\t\t\t\tif(arr[j]>arr[j+1])&#123;\n\t\t\t\t\tint temp = arr[j];\n\t\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\t\tarr[j+1] = temp;\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor(int k=0;k&lt;arr.length;k++)&#123;\n\t\t\tSystem.out.println(arr[k]);\n\t\t&#125;\n\n普通排序:\n//从大到小\nclass BubbleSort \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tint[] arr = &#123;19,42,20,23,14&#125;;\n\n\t\tfor(int i =0;i&lt;arr.length;i++)&#123;\n\t\t\tfor(int j =0;j&lt;arr.length;j++)&#123;\n\t\t\t\tif(arr[i]>arr[j])&#123;\n\t\t\t\t\tint temp = arr[j];\n\t\t\t\t\tarr[j] = arr[i];\n\t\t\t\t\tarr[i] = temp;\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor(int k=0;k&lt;arr.length;k++)&#123;\n\t\t\tSystem.out.println(arr[k]);\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n\n//从小到大\nclass BubbleSort \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tint[] arr = &#123;19,42,20,23,14&#125;;\n\n\t\tfor(int i =0;i&lt;arr.length;i++)&#123;\n\t\t\tfor(int j =0;j&lt;arr.length;j++)&#123;\n\t\t\t\tif(arr[i]>arr[j])&#123;\n\t\t\t\t\tint temp = arr[j];\n\t\t\t\t\tarr[j] = arr[i];\n\t\t\t\t\tarr[i] = temp;\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tfor(int k=0;k&lt;arr.length;k++)&#123;\n\t\t\tSystem.out.println(arr[k]);\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n\n查找 sequence\n顺序查找\nimport java.util.Scanner;\nclass SeqSearch \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tScanner myScanner = new Scanner(System.in);\n\t\tint[] arr = &#123;19,42,20,23,14&#125;;\n\t\tint step =0;\n\t\tSystem.out.println(\"输入要查找的数字\");\n\t\tint num = myScanner.nextInt();\n\t\tfor(int i=0;i&lt;arr.length;i++)&#123;\n\t\t\t\n\t\t\tif(arr[i]==num)&#123;\n\t\t\t\tSystem.out.println(\"找到该数字,它是第\"+(i+1)+\"个数字\");\n\t\t\t\tstep =1;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif(step!=1)&#123;\n\t\t\tSystem.out.println(\"不存在数字\"+num);\n\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n二维数组int[] arr[] or int[][] arr  or int arr[][]\n创建方式：\n\n初始化数组\n//创建一个二行三列数组\nint arr[][] = new int[2][3]\n先声明再定义\n//创建一个二行三列数组\nint arr[][]; \narr[][] = new int[2][3];\n二维数组的使用：\n\n\nclass TwoArray \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\t//输出以下\n\t\t/*\n\t\t\t1\n\t\t\t22\n\t\t\t333\n\t\t\t4444\n\t\t\t55555\n\t\t*/\n\n\t\tint arr[][] = new int[5][];\n\n\t\tfor(int i=0;i&lt;arr.length;i++)&#123;\n\t\t\tarr[i] =new int[(i+1)]; \n\t\t\tfor(int j=0;j&lt;arr[i].length;j++)&#123;\n\t\t\t\tarr[i][j] = i+1;\n\t\t\t\tSystem.out.print(arr[i][j]);\n\t\t\t&#125;\n\t\t\tSystem.out.print(\"\\n\");\n\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n静态初始化\nint[][] arr = &#123;&#123;1&#125;,&#123;2,2&#125;,&#123;3,&#125;&#125;\n\n注意：二维数组中父级数组中的元素必须是数组不能是直接元素（基本数据类型）\n\nint[][] arr = new int[][]&#123;&#123;1&#125;,&#123;2,2&#125;,&#123;3,&#125;&#125;\n\n\n\n","slug":"JAVA基础","date":"2023-03-12T14:27:00.000Z","categories_index":"Cate","tags_index":"Tag","author_index":"无言"},{"id":"a6b82868af4785482b869dc5d958966b","title":"Article Title","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2020-08-15T10:49:36.000Z","categories_index":"Cate","tags_index":"Tag","author_index":"TriDiamond"},{"id":"282ca770e6df8001dbda062738b2a12a","title":"java面向对象","content":"类与面向对象基础（OOP）1.类的创建\n代码示例\nclass OOP \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tCat cat1 = new Cat();\n\n\t\tcat1.name = \"猫\";\n\t\tcat1.age = 18;\n\t\tcat1.color = \"绿色\";\n\t\t\n\t\tSystem.out.println(\"信息:\"+cat1.name+cat1.age+cat1.color);\n\t&#125;\n&#125;\n\nclass Cat\n&#123;\n\tString name;\n\tint age;\n\tString color;\n&#125; \n\n\n\n\n类是抽象的、概念的、代表一类事物，比如人类，汽车。。。。即它是数据类型\n对象是具体的，实际的，代表一个事物，即实例\n类是对象的模板，如汽车是类，奥迪牌汽车、宝马牌汽车、这些是属于汽车类的对象\n\n\n\n2.对象在内存中存在的形式\n通过cat类创建的对象会在堆中创建一个地址，该地址中存放的是对象的属性值，如果值为基本数据类型则在堆中存放，如果值为引用数据类型即字符串，则会在方法区创建地址保存属性值。\n3.类的访问修饰符与属性默认值\n属性的定义语法：访问 修饰符 数据类型 属性名；\n\n方法修饰符共有四种：public，private，proctected，默认\n\n\n属性的定义类型包含多种类型可以是基本类型或引用类型\n\n创建对象时，如果不给属性赋值，则属性会使用它的默认值，默认值与数组默认值相同\n\nbyte，short，int，long是0，float，double是0.0，char是\\u0000，String是null,Boolean是false\n\n\n\n4.对象的创建与访问创建：\n\n先声明再创建\nCat cat;\ncat = new Cat();\n直接声明并创建\nCat cat = new Cat();\n\n访问：对象.属性\n5.类与对象的地址分配与传递Peson p1 = new peson();\np1.name = \"啊啊啊\";\np1.age = 18;\nPeson p2 = p1;\nSystem.out.print(p2.age);//18\n\n如果将一个对象赋值给另一个对象，则二者所使用的内存空间相同，即p1随p2变化，p2随p1变化\n6.类与对象Detail\n类与对象的内存分配机制\n\n栈：一般存放基本数据类型（局部变量）\n堆：存放对象\n方法区：常量池（常量，如字符串），类加载信息\n\n\n创建对象流程分析\nPerson p = new Person();\np.name = \"来找我\";\np.age = 18;\n\n\n加载Person类信息（属性与方法，只会加载一次）\n在堆中创建对象内存比分配空间，进行默认初始化\n把对象空间地址赋值给p，p就执行对象\n进行指定初始话，如：p.name = “来找我”; p.age = 18;\n\n\n\n方法方法的特点：复用性，可封装性\n方法的创建class Function \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tFun ren = new Fun();\n\t\tren.age = 10;\n\t\tren.name = \"老好\";\n\t\tren.run();//开始跑起来了\n\t&#125;\n&#125;\n\nclass Fun\n&#123;\n\t//public 公开的\n\t//void 没有返回值\n\t// run() 方法名与行参\n\tString name;\n\tint age;\n\tpublic void run()&#123;\n\t\tSystem.out.println(\"开始跑起来了\");\n\t&#125;\n&#125;\n\n\n方法的参数（parameter）class Function \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tFun ren = new Fun();\n\t\tren.age = 10;\n\t\tren.name = \"老好\";\n\t\tren.run();//开始跑起来了\n        //调用并传参\n\t\tren.add(2000);\n\t&#125;\n\n\t\n\t\t\n&#125;\n\nclass Fun\n&#123;\n\t//public 公开的\n\t//void 没有返回值\n\t// run() 方法名与行参\n\tString name;\n\tint age;\n\tpublic void run()&#123;\n\t\tSystem.out.println(\"开始跑起来了\");\n\t&#125;;\n\t//计算0加到n的值\n\tpublic void add(int n)&#123;\n\t\tint sum =0;\n\t\tfor(int i =0;i&lt;=n;i++)&#123;\n\t\t\tsum+=i;\n\t\t&#125;\n\t\tSystem.out.println(sum);\n\t&#125;\n&#125;\n\n\nadd(int n)：（int n） 为数据类型为int的形参\nren.add(2000)： （2000） 传入的实参\n注意：形参需要标注数据类型，实参需要与形参数据类型相同\n方法的返回值class Function \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tFun ren = new Fun();\n\t\tren.age = 10;\n\t\tren.name = \"老好\";\n\t\tren.run();//开始跑起来了\n\t\tren.add(2000);\n\t\tSystem.out.println(ren.add1(10,20));\n\t&#125;\n\n\t\n\t\t\n&#125;\n\nclass Fun\n&#123;\n\t//public 公开的\n\t//void 没有返回值\n\t// run() 方法名与行参\n\tString name;\n\tint age;\n\tpublic void run()&#123;\n\t\tSystem.out.println(\"开始跑起来了\");\n\t&#125;;\n\t//计算0加到n的值\n\tpublic void add(int n)&#123;\n\t\tint sum =0;\n\t\tfor(int i =0;i&lt;=n;i++)&#123;\n\t\t\tsum+=i;\n\t\t&#125;\n\t\tSystem.out.println(sum);\n\t&#125;\n\n\t//计算两个数的和\n\tpublic int add1(int num1,int num2)&#123;\n\t\tint sum =num1+num2;\n\t\treturn sum;\n\t&#125;\n&#125;\n\n\n//计算两个数的和\n\tpublic int add1(int num1,int num2)&#123;\n\t\tint sum =num1+num2;\n\t\treturn sum;\n\t&#125;\n\tSystem.out.println(ren.add1(10,20));\n\npublic：方法表示方式为公开\nint：必定返回一个int类型的数据\nadd1(int num1,int num2)：函数名与两个形参\nreturn sum：返回一个变量的值，变量名为sum\nren.add1(10,20):因为方法带有返回值，所以这里可以认为ren.add1(10,20)等于sum等于30\n方法的引用机制当程序运行到主方法时或者在执行主方法中的方法调用程序时，都会在栈中创建一个对应的方法栈，之后方法中的程序全部执行完毕或者执行到return，销毁对应的方法栈。当主方法栈执行完毕后，将会退出整个程序。\n\n方法的使用（复用性）在日常的开发中，常常需要将某个程序执行多次，这里就需要用到方法。\n示例：要遍历三次数组\nclass Method \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tint[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;\n\t\tMyTools tools = new MyTools();\n\n\t\ttools.Arrlist(arr);\n\t\ttools.Arrlist(arr);\n\t\ttools.Arrlist(arr);\n\n\t&#125;\n&#125;\n\nclass MyTools\n&#123;\n\tpublic void Arrlist(int[][] arr)&#123;\n\t\tSystem.out.println(\"=====================\");\n\n\t\tfor(int i =0;i&lt;arr.length;i++)&#123;\n\t\t\tfor(int j =0;j&lt;arr[i].length;j++)&#123;\n\t\t\t\tSystem.out.print(arr[i][j]+\",\");\n\t\t\t&#125;\n\t\t\t\tSystem.out.print(\"\\n\");\n\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n方法的细节（Detail）\n```javaclass Method{\npublic static void main(String[] args) \n&#123;\n&#125;\n\n}\n\n   访问修饰符（作用:控制方法的访问范围）\n\n   访问修饰符共四种：public、protected、private、默认（不写）\n\n2. &#96;&#96;&#96;java\n   class MyTools\n   &#123;\n   \tpublic void Arrlist(int[][] arr)&#123;\n   \t\tSystem.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n   \n   \t\tfor(int i &#x3D;0;i&lt;arr.length;i++)&#123;\n   \t\t\tfor(int j &#x3D;0;j&lt;arr[i].length;j++)&#123;\n   \t\t\t\tSystem.out.print(arr[i][j]+&quot;,&quot;);\n   \t\t\t&#125;\n   \t\t\t\tSystem.out.print(&quot;\\n&quot;);\n   \n   \t\t&#125;\n   \t&#125;\n   &#125;\n\n\n一个方法最多有一个返回值\n返回的数据类型可以是任意类型，但需要在创建方法时定义\n如果方法要求有返回值，则方法中必须有 return 值；程序，返回的值可以是变量或者常量，但必须符合要求数据类型\n如果是void，则方法可以没有return语句，或只写return；（不能返回任何东西）\n\n\n方法命名遵循驼峰命名法，要求见名知意\n\n方法之中不能嵌套方法，但可以使用方法\n\n\n参数的细节参考链接：\nhttps://www.bilibili.com/video/BV1fh411y7R8?p=208&amp;spm_id_from=pageDriver&amp;vd_source=f24cb303eb5accca215fadb0a6729822\n\n一个方法可以有多个参数，也可以没有参数，如果有用 ，隔开\n参数类型可以是任意类型（基本，引用）\n调用带参方法时，一定要传入对应类型或兼容类型的参数，（兼容可以参考数据类型自动转换部分）\n方法中定义的参数为形式参数，简称形参，方法调用中传入的参数为实际参数，简称实参。注意：形参和实参所对应的数据类型，顺序，个数，必须一致\n\n方法的调用\n方法之间的调用\nclass A\n&#123;\n\tpublic void m1()&#123;\n\t\tSystem.out.println(\"我是A\");\n\n\t&#125;\n\n\tpublic void m2()&#123;\n\t\tm1();\n\t\tSystem.out.println(\"我是B\");\n\n\t&#125;\n\n\n&#125;\n方法之间的跨类调用\nclass A\n&#123;\n\tpublic void m1()&#123;\n\t\tSystem.out.println(\"我是A\");\n\n\t&#125;\n\n\tpublic void m2()&#123;\n\t\tm1();\n\t\tSystem.out.println(\"我是B\");\n\n\t&#125;\n\n\n&#125;\nclass B\n&#123;\n\tpublic void c1()&#123;\n\t\tA m1 = new A();\n\t\tm1.m1();\n\t\tSystem.out.println(\"我是C\");\n\n\t&#125;\n\n&#125;\n跨类调用与访问修饰符有关，如果修饰符为private基本是不行的\n\n执行程序\nclass Method \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t//跨函数调用\n\t\tA funA = new A();\n\t\tfunA.m2();\n\t//跨类调用\n\t\tB funB = new B();\n\t\tfunB.c1();\n\t&#125;\n&#125;\n\n\nclass A\n&#123;\n\tpublic void m1()&#123;\n\t\tSystem.out.println(\"我是A\");\n\n\t&#125;\n\n\tpublic void m2()&#123;\n\t\tm1();\n\t\tSystem.out.println(\"我是B\");\n\n\t&#125;\n\n\n&#125;\nclass B\n&#123;\n\tpublic void c1()&#123;\n\t\tA m1 = new A();\n\t\tm1.m1();\n\t\tSystem.out.println(\"我是C\");\n\n\t&#125;\n\n&#125;\n\n方法的递归（recursion）public void test(int n)&#123;\n    if(n>2)&#123;\n        test(n-1);\n    &#125;\n    System.out.println(\"n=\"+n);\n    \n&#125;\n\n通过函数自身的调用实现循环\n完整代码：\nclass  Recursion01\n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tT tes = new T();\n        tes.test(4);//2,3,4\n\t&#125;\n&#125;\n\nclass T\n&#123;\n\tpublic void test(int n)&#123;\n\t\tif(n>2)&#123;\n\t\t\ttest(n-1);\n\t\t&#125;\n\t\tSystem.out.println(\"n=\"+n);\n\t&#125;\n&#125;\n\n\n运行机制效果图：\n方法的递归（Detail）\n每执行一个方法时，就会建立一个新的独立空间（栈）\n方法的局部变量是独立的，不会互相影响，如 n\n如果在递归方法中使用引用数据类型，此类型将会共享到其他调用的独立空间中\n递归必须向退出递归的条件逼近，不然会出现栈溢出的报错：StackOverflowError\n当一个方法执行完毕，或遇到return就会返回，一般情况下，谁调用方法，返回值就是谁的\n\n方法的重加载（OverLoad）class OverLoad01 \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tFun f = new Fun();\n\t\tint a = f.m(2);//4\n\t\tint b = f.m(2,3);//6\n\t\tf.m(\"哈哈哈\");//哈哈哈\n\t\tSystem.out.print(a+\", \"+b);\n\t&#125;\n&#125;\n\nclass Fun\n&#123;\n\tpublic int m(int n)&#123;\n\t\treturn n*n;\n\t&#125;\n\n\tpublic int m(int n2,int n1)&#123;\n\t\treturn n1*n2;\n\t&#125;\n\n\tpublic void m(String str)&#123;\n\t\tSystem.out.println(str);\n\t&#125;\n&#125;\n\n\n重加载，指同一个方法名的情况下，可以根据参数的不同设置不同的方法程序\n要求：1.方法名相同，\n​            2.参数数量，类型，顺序无要求，但要求存在与之相匹配的方法\n​            3.参数数量与类型、顺序都相同的方法只能出现一次，如m(int a)与m(int b)两个方法只能出现一次\n方法的可变参数class  Auto\n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tT res = new T();\n\t\tres.num(1,2,3,4,5);//如果方法中存在可变参数，可同时传入任意个类型相同的数据\n\t&#125;\n&#125;\n\nclass T\n&#123;\n\tpublic void num(int... nums)&#123;//传入的可变参数以数组形式存在\n\t\tint sum =0;\n\t\tfor(int i =0;i&lt;nums.length;i++)&#123;\n\t\t\tsum+=nums[i];\n\t\t&#125;\n\t\tSystem.out.println(sum);\n\t&#125;\n&#125;\n\n\n\nDetail：\n​            1.每个人方法中只能存在一个可变参数\n​            2.调用形参有可变参数的方法时，可以传入0个或任意个(类型相同)实际参数\n​            3.方法的形参中可以同时传入普通参数与可变参数，但要注意可变参数必须放在形参列表的最后面，且传参时，要符合要求\n​            4.可变参数本质就是数组，所以在传参时，可以传入数组\n方法的作用域class Cat&#123;//全局作用域\n\tint age =10;//属于全局变量\n\t\n\tpublic void num()&#123;//可以直接使用age变量\n\t\tString name =\"小李\";//属于局部变量\n\t&#125;\n\t\t\n\tpublic void num1()&#123;//可以直接使用age变量\n        int age =20;//方法中的age与Cat中的age互不影响\n        String name = \"小儿\";//num1中的name与num中的name互不影响\n\t\tSystem.out.println(name)//Error\n        System.out.println(age)//如果方法中存在age变量，则采取就近原则，输出20\n\t&#125;\n&#125;\n\n全局作用域：类            局部作用域：类里面的每一个方法都是一个局部作用域\n全局变量：全局都可以访问的变量，如Cat类定义的属性就是全局变量(属性可以直接赋值，不赋值也可以，因为有默认值)\n局部变量: 只能内部方法与使用的变量，如num方法中的变量就属于局部变量，num1方法无法拿来使用(方法中的变量不能自定义不赋值，因为它没有默认值)\n默认值的问题可以去看数据部分\nDetail：\n\n属性和局部变量可以重名，输出或使用时采取就近原则\n\n在同一作用域下，变量不能重名，在不同作用域下变量可以重名\n\n局部作用域中的变量生命周期短，伴随这程序的执行而创建，当方法执行完毕后就会被销毁。全局作用域中的属性生命周期较长，伴随着类的创建而创建，当类销毁时，才会销毁灭\n\n作用域范围不同：全局变量/属性:可以被本身的局部作用域使用，也可以通过创建对象的形式被外部作用域使用。局部变量/变量：只能中自己的方法中使用\nclass Test \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tA fun = new A();\n\t\tB fun1 = new B();\n\t\tfun.num1();\n\t\tfun1.num2(fun);\n\t&#125;\n&#125;\n\nclass A //在A中的局部作用域调用B中的属性\n&#123;\n\tString name =\"小李\";\n\tpublic void num1()&#123;//方法二\n\t\tB a = new B();\n\t\tSystem.out.println(a.age);\n\t&#125;\n&#125;\n\nclass B//在B中的局部作用域调用A中的属性\n&#123;\n\tint age =19;\n\tpublic void num2(A fun)&#123;//方法一\n\t\tdouble time = 11.00;\n\t\tSystem.out.println(fun.name);\n\t&#125;\n&#125;\n\n全局作用域中的属性可以+修饰符，局部作用域中的变量不可以+修饰符\nclass A //在A中的局部作用域调用B中的属性\n&#123;\n\tpublic String name =\"小李\";\n\tpublic void num1()&#123;//方法二\n\t\tpublic int a = 11; //error\n\t\tSystem.out.println(a);\n\t&#125;\n&#125;\n\n构造器\n基本介绍\n构造方法又叫构造器，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。它有以下几个特点：\n\n方法名和类名相同\n没有返回值，也没有void\n创建对象时，自动调用该类的构造器完成对象的初始化。\n\n\n代码示例\nclass Constructor \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tPerson p = new Person(\"jack\",66);\n        Person p2 = new Person(\"Bob\");\n\t\tSystem.out.print(\"构造器1:\"+p.age+\" \"+p.name);\n        System.out.print(\"构造器2:\"+p2.name);\n\t&#125;\n&#125;\n\nclass Person\n&#123;\n\tString name;\n\tint age;\n\tpublic Person(String pName,int pAge)&#123;\n\t\tname = pName;\n\t\tage = pAge;\n\t&#125;\n    //构造器的重构\n    public Person(String pName)&#123;\n        name = pName;\n    &#125;\n&#125;\n\n\n\n构造器是完成对象的初始化，并不是创建对象\n\n在创建对象时，系统自动调用该类的构造方法\n\n如果程序没有定义构造器，则会默认生成一个隐式的构造器\nclass ConstructorDetail \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tPerson dog = new Person();\n\t&#125;\n&#125;\nclass Person\n&#123;\n\tString name;\n\tint age;\n&#125;\n\n\n\n\n如果定义了构造器原先的隐式构造器将被覆盖，除非以显式的方式再声明一次\nclass ConstructorDetail \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tPerson dog = new Person();\n\t&#125;\n&#125;\nclass Person\n&#123;\n\tString name;\n\tint age;\n\tpublic Person(String pName,int pAge)&#123;\n\t\tname = pName;\n\t\tage = pAge;\n\t&#125;\n\n\tPerson()&#123;&#125;;//显式声明\n&#125;\n\n\n\n\n对象创建流程（1.4版本）\n流程分析\n加载Person类信息(Person)，只会加载一次\n在堆中分配空间\n完成对象初始化，3.1默认初始化 name=null，age=0，3.2显式初始化 name=null，age=90，3.3构造器初始化 name=”小倩“,age=20\n将对象在堆中的地址返回给p（p是对象名，在栈中保存着对象的地址，可以当作是对象的引用）\n\n\n\nthis关键字java虚拟机给每一个对象都分配了this，代表当前对象\n代码实例：\nclass This01 \n&#123;\n\tpublic static void main(String[] args) \n\t&#123;\n\t\tPerson p = new Person(\"tomm\",99);\n\t\tp.print();\n\t&#125;\n&#125;\n\nclass Person\n&#123;\n\tString name;\n\tint age;\n\tpublic Person(String name,int age)&#123;\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t&#125;\n\n\tpublic void print()&#123;\n\t\tSystem.out.println(\"name=\"+this.name+\",age=\"+this.age);\n\t&#125;\n&#125;\n\n\nthis指向示意图\nthis指向调用对象本身，哪个对象调用，this就指向哪个对象\nDetail：\n\nthis关键字可以用来访问本类的属性、方法、构造器\nthis用于区分当前类的属性和局部变量\n访问成员方法的语法：this.方法名(参数列表)\n访问构造器语法：this(参数列表);注意只能在构造器中使用，即只能在构造器中访问另一个构造器，且必须放在第一条语句\nthis不能在类定义的外部使用，只能在类定义的方法中使用\n\nIDEA包的命名规则一般是小写字母+小圆点\ncom.公司名+项目名+业务模块名\n比如: com.goods.sort.model\njava中的常用包java.lang.*  不需要引入，可以直接使用的包\njava.util.*  util包，系统提供的工具包，如：Scanner\njava.net.* 网络包，网络开发\njava.awt.* 做java界面开发，GUI\n包的作用防止出现重名类的情况\n\n\nDetaik：\n​        一个类中最大存在一个package声明\n​        一个包中不能出现多个同名类\n访问修饰符用于控制方法和属性的访问权限\n1.public 对外公开\n2.protected 对子类和同一个包中的类公开\n3.默认 没有修饰符对同一个包中的类公开\n4.private 私有级别，只对类本身公开\n\n注意：类也拥有访问修饰符，且只有public和默认修饰符对类有效\n​    \n类的封装将类中的属性与方法封装起来，通过调用方法的形式访问类\n封装的好处：隐藏实现细节\n​                        可以对数据进行验证操作，保证安全合理\n封装步骤第一步，将类中所有属性设置为私有属性（private）\n第二步，设置set方法，修饰符为public，用于设置与操作属性\n第三步，设置get方法，修饰符为public，用于获取属性\n代码实例：\npublic class Encapsulation01 &#123;\n    public static void main(String[] args) &#123;\n        Person person = new Person(\"李志伟\",18,13000,\"程序员\");\n        person.setPassword(123456780);\n        person.info();\n    &#125;\n\n&#125;\n\nclass Person &#123;\n    public String name;\n    private int age;\n    private double salary;\n    private String job;\n    private int password;\n\n    //构造器\n    public Person(String name, int age, double salary, String job) &#123;\n//        this.name = name;\n//        this.age = age;\n//        this.salary = salary;\n//        this.job = job;\n        //调用函数进行验证，防止功能失效\n        setName(name);\n        setAge(age);\n        setSalary(salary);\n        setJob(job);\n    &#125;\n\n    //方法\n    private int getPassword() &#123;\n        return password;\n    &#125;\n\n    public void setPassword(int password) &#123;\n        this.password = password;\n    &#125;\n\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        if(name.length()&lt;=4)&#123;\n            this.name = name;\n        &#125;else&#123;\n            System.out.println(\"名字长度不能大于四位，默认设置名称为jack\");\n            this.name = \"jack\";\n        &#125;\n    &#125;\n\n    public int getAge() &#123;\n        if(getPassword() ==12345678)&#123;\n            return age;\n        &#125;else &#123;\n            System.out.println(\"对不起，您没有权限,无法查看年龄\");\n            return 0;\n        &#125;\n    &#125;\n\n    public void setAge(int age) &#123;\n        if(age&lt;=120 &amp;&amp; age >=1)&#123;\n            this.age = age;\n        &#125;else&#123;\n            System.out.println(\"年龄必须在1-120之间不能超出范围，默认设置年龄为18\");\n            this.age=18;//设置默认值\n        &#125;\n    &#125;\n\n    public double getSalary() &#123;\n        if(getPassword()==12345678)&#123;\n            return salary;\n        &#125;else &#123;\n            System.out.println(\"对不起，您没有权限，无法查看工资\");\n            return 0.00;\n        &#125;\n    &#125;\n\n    public void setSalary(double salary) &#123;\n        this.salary = salary;\n    &#125;\n\n    public String getJob() &#123;\n        return job;\n    &#125;\n\n    public void setJob(String job) &#123;\n        this.job = job;\n    &#125;\n\n    public void info()&#123;\n        if(getPassword() == 12345678)&#123;\n            System.out.println(\"姓名=\"+getName()+\" 年龄=\"+getAge()+\" 工资=\"+getSalary()+\" 工作=\"+getJob());\n        &#125;else &#123;\n            System.out.println(\"姓名=\"+getName()+\" 工作=\"+getJob());\n        &#125;\n    &#125;\n&#125;\n\n\n类的继承提高代码的复用性\n提高代码扩展性\n\n子类会拥有父类的方法，父类又叫基类、超类，子类又叫派生类\nDetail1.私有的属性或方法不可以在子类中使用\n2.默认的属性或方法在同包下的子类中可以使用\n3.其他不可以被访问的属性和方法，可以通过父类提供的公共方法访问\n4.子类在使用本身的构造器之前都会先调用父类的构造器\n5.无论父类中的构造器有无参数，子类对象被调用时，都会先调用父类构造器再调用本身的构造器\n6.java所有的类都是Object类的子类，Object类所有Java类的基类\n7.父级构造器的调用不只是调用父级，而是会一直调用到Object类\n8.子类最多继承一个父类，子类如果想基础多个父类：a 被 b 继承  b再被 c继承，由此c就继承了a和b的方法与属性\n9.类的继承不能滥用必须复合逻辑，如：cat extends Animal  猫是动物的一种，所以猫可以直接使用动物类\n继承过程\n\nsuper获取父类构造器的方法\n子类构造器的第一行默认会存在应该super()方法获取父类的默认构造器\n子类构造器如果不想获取默认构造器，需要在super(实参)中传入对应构造器参数对应的实参，无论你有没有super，调用子类构造器都必须调用父类构造器\nsuper()方法必须且只能放在子类构造器第一行的位置\n注意：this与super无法共存于一个构造器中\nDetail1.可以访问父类的属性，但不能访问父类的private属性\n\n2.可以访问父类的方法，但不能访问父类的private方法\n3.访问父类的构造器：super(参数) 只能放在子类构造器的第一句，如果子类没有定义构造器，会在默认构造器中定义一个super()\n子类中通过super调用方法与不通过super调用方法的区别\n 1.super.方法( ) 不会在本类中寻找方法，直接从父类中找，如果父类还有父类，则遵从就近原则\n 2.方法()或this.方法() 先在本类中找方法，找不到再去父类找\n方法重写与覆盖\n注意事项：\n​            1.子类方法的参数与名称要与父类方法的参数与名称完全一样\n​            2.子类方法的返回类型必须与父类方法返回的类型一样，或者是父类返回类型的子类，比如：父类返回类型为Object，子类返回String，String属于Object，所以可以\n​            3.子类方法的访问修饰符的访问范围可以大于父类，但不能小于父类方法的访问范围，public&gt;protec ted&gt;默认&gt;privacy\n类的多态方法的多态：方法中的重载\n对象的多态：\n\n对象的编译类型和运行类型可以不一样\n编译类型在创建时就固定了，运行类型可以后面添加\n“ = ” 左边是编译类型，右边是运行类型 运行类型是编译类型的子类型\n\n\n向上转型\n在遵守访问权限的情况下，可以调用父类所有的方法\n不能调用父类中没有，但子类中有的特有方法\n编译时，能调用那些方法是编译类型决定的(父类中有的方法或与子类共有的方法才能被调用)\n运行时，看运行类型的具体实现(按照子类方法的内容来)\n\n向下转型\n子类声明 子类名称 = （子类声明）父类名称\n能调用父类中没有，但子类中有的特有方法\n编译类型是子类，运行类型也是子类\n要求父类的引用必须指向子类(父类之前是子类的编译类型，子类之前是父类的运行类型)\n\n\n注意：属性没有重写的说法，属性值看的是编译类型的值\ninstanceof 对所属关系进行判断，判断对象的运行类型是否为XX类型或者为XX类型的子类型\n\n动态绑定机制方法有动态绑定，属性没有\n当调用对象方法时，该方法会和该对象内存地址/运行类型进行绑定(调用父类中无论什么方法都会先找子类[运行类型]，子类[运行类型]没有再用父类的)\n调用对象属性时，没有动态绑定，会直接用当前对象中的属性，找不到才去用子类或父类的\n多态数组\n将多个子类对象以运行类型的形式存到父类编译(对象)数组中\n多态参数运行类型得参数为，起本类构造器参数+父类构造器参数\n","slug":"java面向对象","date":"2020-08-15T10:49:36.000Z","categories_index":"Cate","tags_index":"Tag","author_index":"无言"},{"id":"387214eb2cf808ac2891ae56d9c349b8","title":"专升本笔记","content":"名词：​        主要用作主语或宾语\n冠词:​        a/an/the  放在名词前面\n代词：​        起代替作用的词（代词出现的句子，一定有答案）  \n​            I/we/you/he/she/it/they (主格人称代词，放在句子开头做主语)\n​            me/us/you/him/her/it/them (宾格，做宾语位于介词或者动词之后)\n​            例句: she loves (me) .\n&amp;&amp;&amp;重点&amp;&amp;&amp;代替物的形容词性物主代词：​            位于名词之前代指物品的归属\n​            my/our/your/his/her/its/their\n​            例句：I love (my) mum .\n名词性物主代词：​            mine/ours/yours/his/hers /its/theirs\n​            二合一：形代+名词\n​            例句：I love (mine)；\n&amp;&amp;&amp;重点&amp;&amp;&amp;名词性物主代词之后禁止再出现名词\n&amp;&amp;&amp;总结&amp;&amp;&amp;背单词不可怕，知道位置，判断词性，辨析词义\n代替人的反身代词：​                myself/ourselves/yourself/yourselves/himself/herself/itself/themselves\n&amp;&amp;&amp;重点&amp;&amp;&amp;反身代词是宾格的进化，用法：主语和宾格是同一个人，则宾格一定要写成反身代词\n例句：she loves (herself) .\n代替不同数量的人与物（不定代词）：​    both: 2/2 两者都\n​    neither：0/2 两者都不\n​    either: 1/2 两者之一\n​    all： 3/3  3者以上的都\n​    none：0/3 3者以上的都不\n​    much：不可数，表示很多\n​    many：可数，表示很多\n​    例句：I have 2 brothers . Both are teachers. \n​    复数用are 单数用is\n指示代词：​    this: 这个，表示近处\n​    that：那个，表示远处\n​    these：这些个，表示近处+名词复数\n​    those：那些个，表示远处+名词复数\n疑问代词：​    what：什么\n​    who：谁\n​    where：在哪里\n​    whose：谁的\n​    which：哪一个\n关系代词：​    用在定语从句中\n形容词&amp;副词​    形容词：修饰名词、代词、表示人或事物的特性、状态、特征或属性\n​    副词：修饰、限制动词或形容词、表示时间、频率、范围、语气、程度等\n形容修名，副修动，两动之间要有to\n&amp;&amp;&amp;重点&amp;&amp;&amp;长难句分析时：遇到形容词副词，直接视为软柿子，可直接忽视(删掉)即可\n在做阅读理解时，在句中遇到形容词副词，直接视为软柿子，形容词副词里面有答案\n动词动词可分为系动词、助动词、情态助动词、基本助动词、短语动词、情态动词和非谓语动词\n主语之后一般是动词、\n谓语动词有三态：\n​        时态、语态、三单\n介词一般用于名词或代词前面，表示该词与句中其他成分的关系。同时介词用法也很灵活，同一个介词可以表达多种含义，介词可以分为时间介词、地点介词、方式介词、原因介词、数量介词和其他介词\n数量较多，考点比较分散，是拉分的内容\n例：of 、 about、 from、for\n一般在动后名前\n连词连词是用来连接词与词、词组与词组或句子与句子、表示某种逻辑关系的虚词，可以表示并列、承接、转折、顺承、选择、假设、比较、让步等关系、无修饰作用\nAnd 、but、so、///as well as\nIf   、 when 、 because 、although\n数词表示数量或顺序的词叫做数词。英文中数词分为基数词和序数词，可修饰名词\n感叹词 表示说话时喜悦、惊讶等情感的词，无修饰作用\n助动词协助主要动词构成谓语的词叫助动词，也叫辅助动词\ndo 、did、does、be、can \n\n句有标点一定是句子\n1.be形中有副，形容词+ly =副词\n​    Yesterday，it rained &lt;- heavily. I was badly(bad) ill;\n2.冠形后有名,可数名词单数不能裸奔\n​    I love delicious apples(apple).\n3.冠名中有形，形=名词+尾椎\n​    I love an interesting(interest) book.\n4.动介后用宾，宾格、反身代词，ing\n​    I love my mother. my mother loves me( I ). \n​    I love my mother. my mother loves herself( Iher). \n​    I love my mother. she is interested in listening(listen) music.  \n5.名后有句且不完整是定从\n​    I have a book  which/that is 5 yuan. 关系代词\n6.动后有句是宾从\n​    my mother said it was a book.\n7.逗号有连是状从\n​    Because you are new，I will help you.\n8.未做，目的用 to do\n​    I watch this video to learn （learn） English.\n9.主伴doing，被伴done\n​    Listening（losten） to music ,he brushed teeth.\n10.完成，被动记心上\n​    so far,I have fininshed the work.\n​    so far:现在完成时的标志\n语\n主语：主语是一句话的中心，表示句子中所说的是 谁 或 什么\n\n谓语：说明主语的动作或状态，也是句子的主题部分，一般由动词充当\n\n宾语：宾语是动作行为的对象，说明主语在做什么\n\n定语：句子中用来修饰名词或代词。\n\n例句:I love interesting books.  Interesting 是形容词做定语\n\n\n表语：系动词之后的部分是表语，说明主语的状态，可以是词或句子\n\n例句：I am a teacher\nI am hungry\n\n\n状语：表示状态的：时间、地点、原因、结果、目的、方式、条件等。\n\n宾语补足语：补充宾语的动作\n\n例句：I call you lilei.\n\n\n\n五种基本类型\n主+谓   例句：I go  （主谓结构里的动词，一定是不及物动词）\n主+系+表  例句：I am a teacher\n主+谓+宾  例句：I love interesting books.\n主+谓+宾+间接宾语+直接宾语\n例句：I give him a book  主  谓  人  物（人物无关系）\n间接宾语是人\n直接宾语是物\n\n\n主+谓+宾+宾语补足语  \n I call him jim. 主 谓 人  人物有关系\n\n\n\n时态和语态动词的变化\n1—3是谓语动词\n4—7是非谓语动词\n独立谓语do、dose、did\n复合谓语情态动词+do情态动词+动词原型\n常见情态动词\ncan——could\nmay——might\nmust——must\nwill——would 可用于任何人称\nshall——should  只能用于第一人称之后\n将会——应该\n助动词+非谓语be动词 + {doing/to do/done}\nhave + {doing/to do/done}\nam/is/are + doing 现在进行时\nwas/were + doing 过去进行时\nam/is/are + to do = will do 一般将来时\nwas/were + to do = would do 过去将来时态\nbe done 被动语态\nhave/has done 现在完成时\nhad done 过去完成时\nwill have done 将来完成时\n否定句与一般疑问句助动词或情态动词后+not 表示否定句\n助动词或情态动词+not 放在主语前面，表示一般疑问句\n独立谓语与复合谓语相似，原型+not\n时态——一般现在时谓语构成原型do || 三单 does\n考点：主谓一致\n单数形式人称\n\n\n\n主格\n宾格\n形代\n名代\n\n\n\n第一人称\nI\nme\nmy\nmine\n\n\n第二人称\nyou\nyou\nyour\nyours\n\n\n第三人称\nhe\nhim\nhis\nhis\n\n\n\nshe\nher\nher\nhers\n\n\n\nit\nit\nits\nis\n\n\n主语是第三人称单数用三单形式（he/she/it）\n名词的单复数和动词的单复数在形式上是相反的，即名词+s为复数，不加s为单数，动词+s为单数，不加s为复数\n复数形式人称\n\n\n\n主格\n宾格\n形代\n名代\n\n\n\n第一人称\nwe\nus\nour\nours\n\n\n第二人称\nyou\nyou\nyour\nyours\n\n\n第三人称\nthey\nthem\ntheir\ntheirs\n\n\n区分两格区分：主格用在谓语前，作主语\n​                    宾格用在及物动词或者介词后，作宾语\n两代区分：靠后面跟着的词性及含义\n​                    形代：……的 + 名词\n​                    名代：……的，不能加名词\n一般现在时用法\n经常发生的动作\n\n时间状语：always、often、usually、sometimes、once a week（类型）、every+时间\n\n\n客观事实和普遍真理\n\n例：Earth travels around the sun\n\n\n主将从现与主祈从现\n\n主：主句，将：一般将来时 will do，从：从句，现：一般现在时\n\n主祈从现：主句使用祈使句，从句是一般现在时\n\n句子\n\n陈述句：主谓+其他\n疑问句：\n一般疑问句：助动词或情态动词放句首 后跟主语\n特殊疑问句：特殊疑问词+一般疑问句\n反义疑问句：陈述句，简短的一般疑问句\n\n\n祈使句：\n动词原型开头：open the door pleace\nDon‘t +do 。。。\nLet’s 。。。。\nPlease+动词原型\n\n\n感叹句：\nhow + adj + 主语 + 谓语\nwhat + a/an + adj + 名词 +主语 + 谓语\n\n\n\n\n常见连词：\n\nwhen 当……时候  引导时间状语从句\n\nif 如果  引导条件状语从句\n\nIf 句1，句2  ||  句1 if 句2\n句2是主句，句1是从句    || 句1是主句，句2是从句\n\n\n\nas soon as  一……就 引导时间状语\n\nunless 如果不   条件状语从句\n\nin case 以防万一  条件状语从句\n\nthe moment 一……就 时间状语从句\n\nonce 一但……就  条件状语从句\n\n\n\n\n\n\n时态——一般过去时态谓语构成：过去式\n用法：过去发生的动作\n常用时间状语\nyesterday 昨天\nlast 上次，后面可能加其他时间，形成一个单独时间，例：last + night/week/month/year\njust now 刚才\nthe other day 前几天 ==several days ago\na month ago  一月前，时间+ago 表示之前\nthe day before yesterday 固定搭配，前天\nin+过去年份  例：in 2001\nin the past 在过去\n\n注意before + 过去的时间 \n或者\nby + 过去的时间\n=\n 过去完成时\n时态——一般将来时发生在将来的事情\n谓语构成\nwill + do\n否定形式：won’t\n\n\nam/is/are going to + do\nbe going to 是一个整体，不能在其他地方使用\n例：There is going to be 在there be句型中 如果需要，可以在to 后面加be\n\n\nam/is/are + to do\n\n时间状语\ntomorrow 明天\nthe day after tomorrow 后天\nnext + 时间 \nin the future 在未来\n特殊时间状语\nthis + 时间 或tonight\n\n\n\n位移动词come、go、leave、arrive、fly、return\n位移动词可以用现在进行时态，表达一般将来时\n祈使句+and/or 后句谓语用一般将来时1.辨认祈使句\n\n动词原型开头：Open the door pleace\nDon‘t +do 。。。\nLet’s 。。。。\nPlease+动词原型\n\n2.and 和 or 的区别\n​    1.and表示顺接  A句+B句，A句顺着B句走，翻译成那么\n​    2.or表示转折  A句+B句，A句不顺着B句，翻译成否则\n3.后句 ——&gt; will +do 不用翻译句子\n时态——现在进行时态谓语构成am/is/are +doing\nbe的分类\n系动词：单独使用做谓语——&gt;主系表结构（am/is/are）\n助动词：不可以单独使用，没有含义\n可以加非谓语里面的现在分词（+doing形式）表示现在进行时\n+to do 表示现在完成时\n+done表示被动语态\n\n\n\nbe动词的表现形式\nam/is/are 现在式\nwas/were 过去式\nbeing 现在分词||动名词\nbeen 过去分词\n\n时间状语\nnow 现在\nalways 总是，与进行时associate表示感情\n可以用在一般现在时，与现在进行时两种时态中\n在现在进行时中表达一种感情\n\n\n\n时态——过去进行时态谓语构成was/were + doing\n表示：过去某一时刻正在进行的动作\n一定要有准确的时刻，如seven‘o clock\n时态——现在完成时态谓语构成have/has + done\n三单用has\n时间状语\nalready 已经\nbefore 在……之前、以前\n只有一句话+before 现在完成时\n只有一句话+before+过去时间/句子(谓语是一般过去式)  过去完成时\n句1.句2+before  \n句1谓语动词是一般现在时态，句2就是现在完成时\n句1谓语动词是过去式，句2就是过去完成时\n\n\n\n\nrecently 最近的，近来\nlately 最近的，近来\nyet 还，一般用在否定句当中\n次数 \nthis/it + is + 第几次 + that。。。。 +现在完成时态\nthis/it + was +第几次 + that……  +过去完成时\n\n\never 曾经\nnever 从来都不\nin the past few year  在过去的几年\nin -&gt;during || past -&gt; last 单词改变，意思不变，时态不变\n\n\nfor + 时间段 例 for 5 hours，可以出现在三大完成时态中，如果在其他时态中遇到，可以忽略\nsince + 时间点 例 since 5 hours ago\n句子1+since + 具体时间.后面没有句子 直接现在完成时\n句子1+since + 句子2，句子2中使用了过去式，句子1用现在完成时\nsince + 一般过去式，句子2 ，句子2用现在完成时\n\n\nover these years  多年以来\nso far 到目前为止\nup to now 到目前为止\nby now 到目前为止\n\n注意：看到这些时间状语，用现在完成形式，如果选项中没有现在完成时，也可以选have/has been doing\n重点句型\nIt/this is one of + the + 最高级 + 名词复数 + that + have done\nIt/this is the only one of + the + 最高级 + 名词复数 + that + has done\n\n时态——过去完成时谓语构成had + done\n用法：表示过去的过去\n时间状语\nby + 过去时间\nby + 具体过去时间\nby + 句子(过去时态)\n\n\nuntil then 直到那时\nbefore+过去时间/动作\n\n没有时间状语：过去的过去，必须出现一个过去的时间或者动作A作为参照，还有另外一个动作B，动作B必须发生在动作A之前，这时B用过去完成时\n时态——将来完成时谓语构成will+have done\n时间状语by + 将来的时间\n将来的时间：\n\n具体的将来的时间：tomorrow,this term\n+句子：the time +句子(do/does)\n\nby+将来时 ——&gt; will have done\nby+the time 句子(do/does)\nhad done：\nby + 过去时间\nby + the time + 句子（did）\nby + now have/has done\n被动语态谓语构成be+done\n当主动的谓语是独立谓语里面的原型或三单时，就是am/is/are\n当主动的谓语是独立谓语中的过去式时，使用be动词was/were\n当主动的谓语是be+doing的形式时，使用being\n当主动的谓语是will/have/had ,使用been\n时态的被动与主动\n\n\n时态\n时态的主动形式（独立谓语）\n时态的被动形式\n\n\n\n一般现在时\ndo/does\nam/is/are + done\n\n\n一般过去时\ndid\nwas/were + done\n\n\n现在进行时\nam/is/are doing\nam/is/are +being+done\n\n\n过去进行时\nwas/were doing\nwas/were + being +done\n\n\n现在完成时\nhave/has done\nhave/has + been + done\n\n\n过去完成时\nhad done\nhad + been + done\n\n\n将来完成时\nwill have done\nwill have +been +done\n\n\n一般状态不属于情态动词,需要be动词变位形式+done就行\n进行状态 +being\n完成状态+been\n无被动不及物动词无被动\n\nhappen 发生\ntake place 发生\noccur 发生\nbreak out 爆发\nbelong to 属于\nprove 证明\nappear 出现  disappear 消失\nconsist of  由……组成\n\n主动表被动\nneed 需要\n当主语为物，need为实义动词\n+动词ing形式，表被动 \n\n\nrequire 依赖于，需要\n+动词ing形式，表被动\n\n\nwant 想\n+动词ing形式，表被动\n\n\nbe worth 值得被\n+动词ing形式，不能有宾语\n\n\n\n与副词联用表被动\nread 读\nwrite 写\ndraw 画\nwash 洗\nclean 清理\nbake 烤\nburn 燃烧\nopen 打开\nlock 锁住\ncut 切\nshut 关闭\nsell 出售\nwear 穿\nmove 移动\n\n感官动词特点：无被动，无进行，后面+形容词(adj.)\n\nlook 看起来\nsmell 闻起来\nsound 听起来\ntaste 尝起来\nfeel 摸起来\n\n做题技巧时态：找时间状语，找不到就找动作\n语态：看主被动关系\n非谓语动词两种能力1.区别谓语和非谓语谓语：分为两大类\n\n独立谓语\ndo，does对应一般现在时\ndid 对应一般过去时\n\n\n复合谓语\n情态动词+do\n助动词+非谓语\n\n\n\n非谓语：\n\n首单词to：不定式  表示将来的时间，主要作主语和宾语\nto do 一般式  {to learn}\nto be done 过去式 {to be learned} 强调将来的被动\nto have done 完成式 {to have learned}\nto have been done 完成被动不定式\nto be doing 进行式\n\n\ning形式，首单词带有ing形式，主要作主语和宾语\ndoing 一般式\nbeing done 被动式 强调正在进行的动作\nhaving done 完成式\nhaving been done 完成被动式\n\n\n过去分词 表示过去的时间\n单独的done\n\n\n\n2.区别主动和被动第一种被动：be done\nbe：\n\nam/is/are\nwas/were\nbegin\nbeen\n\n第二种被动：单独的done \n两大原则一句一谓一句话只能有一个谓语动词\n两谓一连可以出现两个谓语动词，但要用连词\n非谓语的否定所有非谓语的否定都是在最前面加not\nto do —— not to do\ndoing —— not doing\ndone —— not done\n不定式 表目的考点：记忆性(固定搭配)\n​            分析性(判断分析)\n不要弄混，分析的别记，记的别分析\n不定式的各种表现形式\nto do\nto be done\nto be doing\nto have done，后面有过去的时间用\nto have been done，后面有过去的时间用\n\n常考固定搭配\nbe done to do\nbe said to do 据说\nbe reported to do 据报道\nbe estimate to do 据估计\nbe suppoesd to do 应该\n\n\nused 短语\nused to do 过去常常\nbe/get used to doing 习惯于\nbe used to do 被用来做……\n\n\nbut do 和 but to do\n规则：\nbut前有do，后无to，用but do\nbut前无do，后有to，用but to do\n\n\nbut 后面do指动词原型，前面do就是动词do\n常考句型\nhave nothing to do but do\nhave no choice but to do\ncan’t help but do(固定搭配：只能做某事)\ncan’t help doing(固定搭配：情不自禁做某事)\ncan’t help （to） do sth 无能为力做某事\n\n\n\n\n\n不定式作状语\n目的状语 \n结果状语\n放于句中\nto do 前+only\n出乎意料的不好结果\n主动：only to do\n被动 only to be done\n\n\n\n不定式作宾补\nadvise sb to do 建议某人做某事\nallow sb to do 允许某人做某事\nask sb to do 要求某人做某事\nencourage sb to do  鼓励某人做某事\nforce sb to do 强迫某人做某事\n\n不定式作宾语\ncan’t afford to do\nafford 通常用于can’t或couldn’t之后\nafford后面可以直接+名词或者不定式\n+sth 名词 买得(不)起\n+to do 做得(不)起\n\n\n\n\ndecide to do 决定做某事\n= be determined to do ……\n=make up one‘s mind to do ……\n\n\nfail to do 做某事失败\n反义短语 succeed in doing …… 成功做某事\n\n\nintend to do  打算做某事\nintention 名词形式\nby intendtion = on purpose 故意的\ntend to do  趋向于……，往往……\n\n\nplan to do 计划做某事\nmean to do 打算做某事\nmean doing 意味着\n\n\nmanage to do 想方设法做成某事下·\noffer to do 主动提出做某事\npretend to do 假装做某事\npromise to do 承诺做某事\nrefuse to do 拒绝做某事\nforget to do  忘记去做某事\nforget doing 忘记做过某事 \n\n\n\n动名词答案设置\ndoing\nbeing done\nnot doing\n逻辑主语+doing\n逻辑主语，逻辑上的主语\n形容词性物主代词\n名词的所有格，例1：student’s或者students’\n\n\n\n\n逻辑主语+not+doing\n\n固定搭配\nIt is no use doing 做……没用\nIt 形式主语\nIt is + 客观类形容词adj\n客观类形容词(形容事情难易程度)：\nimportant 重要的\nnecessarily 必要的\neasy 容易的\nhard 努力的\ndifficult 困难的 \ncomplicated 复杂的\npossible 可能的\nimpossible 不可能的\n\n\nIt is + 主观类形容词(形容性格) + of + sb to do……\nkind 善良的\nconsider 体贴的\nclever 聪明的 \nsmart 聪明的\nstupid 愚蠢的\n\n\n\n\nIt is no good doing 做……行不通\nThere is no point doing 做……没有意义\nspend time （in）doing 花费时间做某事\n\n补充Spend 花费（时间/金钱） 出现spend 后面需要+sth或者 in doing形式，in可以省略\nspend——spent —— spent\ntake 花费(时间) 主语可以是It/sth 后面+to do\ntake—— took —— taken\ncost 花费(金钱/时间) 主语是物\ncost——cost——cost\npay 花费(金钱) 主语是人 for sth\npay——paid——paid\n困难句型 主语用名词形式\nhave difficulty (in) doing 做某事有困难\nhave no difficulty in doing sth 感觉做某事没有困难\nhave trouble (in) doing 做某事有麻烦\nhave problem (in) doing 做某事有困难\n\n表示否定，在have后面+no\nno 放于名词前\nnot 放于动词前，not不能单独使用，要放在助动词或者情态动词后面\nto为介词的短语(后面跟ing形式)\nlook forward to 期望，希望\nget used to = be accustomed to = be used to doing 习惯于做某事 \nbe addicted to 沉迷于(某项事物)\nobject to 反对做某事\nobjection 变成名词后面跟to还是介词短语\n\n\nlead to 导致\npay attention to  关注\npay more attention to 更多的关注\n\n\nstick to 坚持+ 抽象名词（dream，promise，belief(信仰)）\ninsist on 坚持 + doing 形式 表观点\npersist in 坚持 + doing 形式 表动作\n\n\nattend to sb 照顾某人 = look after sb =take care of sb\nattend a meeting 参加一个会议\n\n\ncontribute to\n可以跟良性词汇：succeed，development，Heath 翻译成有助于\n可以跟恶性词汇：failure，illness  翻译成导致\n\n\nwhen it comes to 当谈论到……的时候\nbe similar to 与……相似\nbe familiar to \nto+sb  对于某人来说是熟悉的\nto+with  熟悉某人某物\n\n\nthanks to 多亏了\ndevote …… to……\ndevote+宾语(time/life/oneself）) to …… \n\n\nattribute …… to …… \n如果attribute后跟成功，表示归因于\n如果attribute后跟失败，表示归咎于\n\n\nsee to it that +宾从 确保\nadapt to  \nadapt 做不及物动词 表示适应**(生活，环境，天气)**\nadapt 做及物动词 adapt oneself too = adjust oneself to 表示适应**(生活，环境，天气)**\nadapt 做及物动词 改写(小说剧本)\n\n\nadopt to\nadopt vt +建议，表示采纳(建议) \nadopt + 孩子 ，表示收养(孩子)\n\n\nprefer……to……\nprefer sth1 to sth2 相当于sth2更喜欢sth1\n例句：she prefer coffee to tea.\nprefer doing1 to doing2 相当于做doing2更喜欢做doing1\n例句：she prefer watching to reading.\nprefer to do sth1 rather than do sth2 = would rather do …… than do 宁愿做sth2，也不愿意做sth1     \n\n\nadjust oneself to = adapt oneself to …… 适应(生活环境天气)\nowing to = because of 由于……\naccess to 使用……的权利\naccording to 根据\nbelong to 属于\nagree to 同意 + advice/suggest/proposal + that + 虚拟语气\nconfess to 坦白 + doing 坦白做某事\naffect to = influence 影响\naffection 情感，感情\neffect 名词影响 = influence\ncome into effect = go into effect 法律法规的生效\nhave am effect on 对……有效\neffect == influence == impact\n\n\neffective adj. 有效的-&gt;起作用\nefficient 高效的-&gt;效率的高低\nefficiency n. 高效 \n\n\n\n动名词作宾语\nallow doing  sth允许做某事\nallow one’s doing sth允许怎么说\nappreciate doing  sth喜欢/感激做某事\nenjoy doing sth享受做某事\navoid doing  sth躲避做某事\nmind doing  sth介意做某事\nstop doing sth 停止做某事\nstop to do sth 停下来去做某事\nfinish doing sth 完成做某事\npractice doing sth完成做某事\nsuggest doing sth 建议做某事\nkeep doing sth 不断做某事，一直做某事\nkeep + adj 保持状态\nkeep + n 保留某物\n\n\ndelay doing sth 推迟做某事\nconsider doing sth考虑做某事\nconsider + it+ adj + to do/名词性从句 = think + it +adj + 不定式+名词性从句\nconsider +ate  体贴的，周到的，主观类形容词\nconsider + able 大量的，巨大的\nconsideration \ntake sth into consideration = take sb into account  把……考虑在内\nunder consideration 处于考虑当中\nunder control 处于控制中\nunder threat 处于威胁中\nunder + discussion 处于讨论中\nunder + pressure = under stress 处于压力中\n\n\nconsidering \n+that从句 或者+what从句 鉴于某种情况\n\n\n\n\n\n\nadmit doing sth 承认做过某事\nregret doing sth 后悔做过某事\nrisk doing sth 冒险做某事\nescape doing 逃避做某事\nimagine doing sth 想象做某事\npostpone doing sth = delay doing sth 推迟做某事\ncan’t help doing sth 情不自禁做某事\nfeel like doing sth 想要做某事 \n\n分词主要作枝叶部分\n做题方法：\n找逗号：\n辨认题型\n为找主语做好准备\n\n\n找主语：\n如果空格出现在逗号之前，那么逗号之后第一个名词或者是代词就是主语\n如果空格出现在逗号之后，那么逗号前从前往后第一个名词或者是代词为主语\n\n\n判断关系\n判定主语和选项动词之间的关系\n主动关系\n答案是doing形式\n答案是having形式\n\n\n被动关系\n答案是done形式\n答案是having been done形式\n\n\n\n\n\n\n看先后\n看选项中的动词和该句话的谓语动词之间的先后顺序\n如果两个动作同时发生，无明显的先后，选doing或者是done\n如果选项动词发生在谓语动词之前，那么选having down或者having been down\n\n\n\n\n\n小诀窍：\n\n主语如果是物，往往选被动的，\n选项中如果既有谓语又有非谓语，我们需要根据一句一谓或者两谓一连原则排除\n如果空格后，有by，答案选被动的\n选项中有ask，一定选被动的\nasked\nhaving been asked\n\n\n分词前可以直接用连词\n连词：if，unless，when，though = even though 虽然\n\n\n表示被动的done和having be done后面 不可以加宾语\n空格后，逗号前，出现for+时间段、before或次数，一定选带有having的\n\n作状语定义在主从复合句中由从句所作的状语称为状语从句，它可以用来修饰动词、形容词、或是整个句子\n学习方法准确掌握每一个连词的含义是掌握状语从句的关键\n同时注意主从句的时态呼应\n分类\n时间状语从句\nthe moment = as soon as ——   一……就\n发生在将来，都适应于主将从现\n发生在过去，主句从句都要用done\n\n\nNo sooner…… than…… = hardly……when……  = scarcely …… when…… —— 一……就\nnot……until——直到……才\nbefore 在……之前\nsince 自从 后面一般+过去时，主句用现在完成时\n\n\n地点状语从句\nwhere引导\n\n\n原因状语从句\nsince\n\n\n目的状语从句\n结果状语从句\n条件状语从句\nif \n真实的条件：主将从现\n虚幻的条件：虚拟语气\n\n\nunless——如果不，除非 = if not\nas long as ——只要 \nas soon as —— 一……就\nas well as —— 一……就\nas far as +句子\nas far as +sb know(s) ——据某人所知\nas far as +sb be concerned—— 就……而言\n\n\nprovided（that) = providing（that) = supposing ——假如\non condition that 条件是\n\n\n方式状语从句\nas/as if\n\n\n让步状语从句\n\n作后置定语作形容词固定搭配固定搭配一般在空前，或者空前前\n当被修饰词是chance，opportunity，ability时，常用不定式一般式作后置定语\ngive sb a/the to do sth 给某人做某事的机会\nsth. be worth doing 某事值得做\nget sth done 使某事/某事被做\nhave sth done 做某事\n形容词/副词 + enough to do …… —— 足够……做\ntransform ……into……——把……东西转换成……东西、\nsb want/need/require+to do  主语是人加todo\nSth …… Doing/to be done 主语是物+这个\nFind: \ndifficulty/problem in doing sth 发现做某事很困难 = find it/sth +adj+to do sth\nfind sb do(短动作)/doing(长动作) sth 发现某人做某事\nfind sth done 发现某事被做 \nfeel sb do/doing 感觉到某人做某事\nfeel sth  do/doing 感觉做某事\nit no use （in） doing sth 做某事是没有用的\nblame sb for sth 因某事而指责某人\nblame sth on sb 把某事归咎于某人\nsb be to blame for sth 某人应该对……负责\nstop to do sth 停下某事去做某事\nstop doing sth 停下某事(正在做的事)\nhave/make/let get + sb do\nhave/make/let get + sth/oneself done\nget sb to do\nhave no desire to do srh 不渴望做某事\nIt/sth be though/believed/reported/said\n+to do 表事情未发生\n+to be done未发生\n+to have done 事情已发送(主)\n+to have been done (被动)\n非谓语做主语思路非谓语做主语：doing——being done，to do —— to be done\n\n注意：经常用it做形式主语代替to do，doing大于to do\n\n非谓语动词做状语doing——done——having done——having been done——to do（目的，为了）\n非谓语做定语放在名词后边：doing——done——having done——having been done——to do（目的，为了）\n做题\n独立主格With +名词(逻辑主语)+非谓语,句子(主(真主语)，谓宾语)\nWith + 名词+doing 表主动\nWith + 名词+done 表被动\nWith + 名词+to do（最常选的） 表主动/被动，为了，能够\n虚拟语气If的虚拟\n\n\n时间\nIF条件句\n主句\n\n\n\n现在\n过去式were\nwould/could/should/might+do\n\n\n过去\nhad done\nwould/could/should/might+have done\n\n\n将来\n过去式(were)\n\n\n\n将来\nshould+do\nwould/could/should/might+do\n\n\n将来\nwere+to do\n\n\n\n省略If从句中存在had、were、should时，去掉if，had、were、should提到句前(首)，如果从句中有否定词，否定词位置不变\nshould的虚拟\n\n\n从句组合\n主动\n被动\n\n\n\n1.adj+that\nshould do、do\nshould be done、be done\n\n\n2.n+that\nshould do、do\nshould be done、be done\n\n\n3.vt+(that)\nshould do、do\nshould be done、be done\n\n\n4.conj(连词)\nshould do、do\nshould be done、be done\n\n\nadj+that\nimportant 重要的\nessential 关键性的\nnecessary 必要的\nvital 极其重要的\nadvisable 建议的\npreferable 更好的\ndesirable 理想的，想要的\nimperative 必然的\nurgent 急迫的，紧急的\nstrange 奇怪的，陌生的\nbetter 更好的\nsorry 对不起的 \n\nn+that\nsuggestion  建议\nadvise 建议\ndemand 要求\nrequirement 要求\norder 命令\ncommand 命令\nproposal 提议   \n\nvt+（that）that可以省略\nadvise 建议\nsuggest 建议\ninsist 坚持\npropose 提议\ncommand 命令\ndemand 要求\ndetermine 决心\nrequire 要求\norder 命令\nrequest 请求  \nask 要求\nrecommend 推荐\n\nconj\nin case 以防万一 \nlest 以防万一\nfor fear that 唯恐…… \n\nwish的虚拟\n\n\n组合\n时态\n形式\n\n\n\nwish+(that)\n现在\n过去式\n\n\nwish+(that)\n过去\nhad done\n\n\nwish+(that)\n将来\nwould、could、might+do\n\n\ntime的虚拟It is（high或about）time（that）使用过去式形式\nwould rather 的虚拟\n\n\n形式\n时态\n形式\n\n\n\nwould rather或would（just）as soon\n现在、将来\n过去式（be用were）\n\n\nwould rather或would（just）as soon\n过去\nhad done\n\n\n注意；如果没有时间状语，后句就用did\n主谓一致1.就近原则离谓语动词近的名词决定唯一的单复数\n\nEither……or…… ——或者……或者……\nNeither……nor——既不……也不……\nnot only ……but also——不但……而且……\nnot……but…… 不但……而且\nthere be…… 有\n\n2.就远原则谓语动词依据较远的主语而确定其形式\n\nas well as —— 和\nas much as\nrather than\n(together/along) with —— 和 \nN1 介词 N2\n\n3.单复数同形\n表示某国人的名词如：Chinese、Japanese、Swiss\n某些动物名词：sheep、fish、deer\n某些带 -s 的名词，如means、series、works\n\n4.特殊主语\nTODO不定式\nDoing动名词\n主语从句\n\n无论主语多长，谓语动词一律用单数\n主从复合句谓语&gt;=2时需要用到连词，连词分为并列连词和从属连词\n并列连词：and/vut/or   构成并列句\n从属连词：构成主从复合句\n特点起点：所有的从句都是从连词开始的\n终点：1.从连词开始，只有一个谓语动词，到句尾结束\n​            2.从连词开始，有两个谓语动词，到第二个谓语动词前结束\n定语从句修饰名词的句子为定语从句\n\n前置定语：\nadj，a（clear）city\n数词\n基数词 five book\n序数词 the second book\n\n\na falling  leaf 正在进行的动作\na fallen  leaf 完成的动作\na swimming pool 一个游泳池，动名词表作用\n\n\n后置定语\na bog swimming in the riner 现在分词短语\na book borrowed from the library 过去分词短语\nsomething to do 不定式短语\nthe boy under the tree 介宾短语\n名词\n\n\n\n概述先行词:被定语从句修饰的名词，放于定语从句之前,先行词分为：人、物、时间、地点、原因几类\n关系词：引导定语从句的连接词，位于先行词之后\n关系分为关系代词和关系副词两类：\n\n关系代词：指代先行词，连接主从句，在句子充当主干成分（即：主语、宾语、表语）\nwhich 代指宾格或主格\n\n\n\nthat 代指宾格或主格\nwho 指代（he/she/I）\nwhom 指代（me/her/him）\nwhose 在从句中充当成分\nas 在从句中充当成分\n\n\n关系副词：在句中充当枝叶成分（即状语）\nwhen 时间状语\nwhere 地点状语\nwhy 原因状语\n\n\n\nThe man who is shaking hands with my father is a policeman.\nThe man：先行词\nwho：关系词\n关系词\n\n\n关系词\n先行词\n从句成分\n\n\n\nwho\n人\n主语或表语\n\n\nwhom\n人\n宾语\n\n\nwhich\n物\n主语或宾语\n\n\nthat\n人或物\n主语或宾语\n\n\nwhen\n时间\n时间状语\n\n\nwhere\n地点\n地点状语\n\n\nwhy\n原因(reason)\n原因状语\n\n\n\n如果从句缺少主干成分(即：主语、宾语、表语)，答案在关系代词中选\n如果从句不缺主干成分，答案在关系副词中选\n再结合先行词最终确定答案\n\n特殊关系词：\n​    whose：\n​        1.whose+n/adj+n\n​        2.先行词既可以是人也可以是物\n​    as:\n​        1.放于句首的用法：As + is/was +done(know、reported、said、estimate，mention提到，expect期待)，\n​        2.放于句中的用法：先行词被the same或such修饰 \n只能使用that的情况\n先行词是不定代词或被不定代词修饰\nall 考的最多的\nanything\neverything\nsomething\nnothing\nany\n\n\n先行词被最高级、序数词、the only或the very 、the way修饰\n最高级\n+the most\n+est\n\n\n序数词\nfirst\nsecond\nthird\n\n\n\n\n先行词既有人又有物\n由连词and进行连接\n\n\n前面已经有which或who\n\n不能使用that的情况\n介词之后，不能使用that\n先行词为人，介词用whom\n先行词为物，介词用which\n\n\n非限制性定语从句\n关系词之前有逗号出现\n处理that外，其他关系词都可以引导非限制性定语从句，使用方法语限制性定语从句几乎一样，只有一点不同：which可以代指逗号前整句话  \n\n\n\n关系副词与关系代词的转换\n关系副词=介词+which\n\nwhy = for which\nwhen=\nin which 当先行词为时间中的year时\non which 当先行词为时间中的day时\nduring whic 当先行词为时间中的期间时：holiday\n\n\nwhere=表示方位的介词+which\non which\nin which\nunder which\nbetween which\n\n\n\n名词性从句从句起名词作用\n名词性从句可以分为：\n\n主语从句：This book is mine.\n宾语从句:I bought a book last week.\n表语从句：This is a book.\n同位语从句：My teacher Mr.Gao\n\n语序问题名词性从句使用陈述句语序：引导词(关系词)+主语+谓语\n引导词的选用that：\n\n没有任何含义\n在从句中不作任何成分\n只有在引导宾语从句时可以省略\n\nif和wether：\n\n有含义：是否\n在从句中不作任何成分\n不可省略\n\nif和wether的区别\n​    1.whether和if在宾语从句中可以互换，但是作介词宾语时连接词用wether\n​    2.wether or not 或 wether …… or not\n​    3.主语从句和表语从句中只能使用wether   \n引导代词\nwhat\n代指说的话，做的事\n在从句中做主语，宾语或表语\n\n\nwho\n指代人\n在从句中做主语\n\n\nwhom\n指代人\n在从句中做宾语\n\n\n\n引导副词\nwhen——时间\nwhere——地点\nwhy——原因\nhow——方式\n\n形式主语和形式宾语形式主语句型：\n\nIt is likely that……\nIt no wonder that……\nIt said/reported that……\nit is +done /adj+that……（主语从句）\n\n形式宾语句型：\n\nthink+it+adj+that从句==consider+it+adj+that从句\n\n疑问词+ever与no matter+疑问词意思：无论什么\n疑问词+ever：\n\n既可以引导名词性从句也可以引导让步状语从句\n\nno matter+疑问词：\n\n只可以引导让步状语从句(有两段，带逗号)\n\n同位语从句的先行词\nfact 事实\n\nnews 新闻，消息\n\ninformation 消息，信息\n\nidea 观点\n\nsb no idea + 连接词** **\n\n\nwords\n\nevidence 证据\n\nwish\n\nsuggestion 建议\n\nadvice 建议\n\npromise 承诺\n\nbelief 信仰\n\nconclusion 结论\n\ndoubt 怀疑\n\n所在肯定句，whether引导\n所在否定句，that引导\n\n\n\nthat引导从句\n常考句型\nThe reason why……\n\nThe reason is that……\n\nThe reason why……is that ……原因是……\n\nThat is why……\n\n\n状语从句从句起副词的作用\n定义在主从复合句中由从句来充当的状语称为状语从句，它可以用来修饰动词、形容词、或者整个句子\n状语从句分类\n时间状语从句\nthe moment/minute/second/instand =as soon as —— 一……就\n发生在将来，都适应主将从现\n发生在过去，都要用过去时\n\n\nNo sooner……than…… = hardly……when…… —— 一……就……\nnot ……until —— 直到……才\nbefore —— 在……之前\nsince\n\n\n地点状语从句\nwhere\n\n\n原因状语从句\nbecause\nas\nsince=not that\nconsidering that 鉴于，顾及到……\nseeing（that）由于\n\n\n目的状语从句\nso that 以便\nin order that 为了\nfor fear that —— 生怕，为了防止(某事发生)\nlest 以防万一\n\n\n结果状语从句\nSo……that —— 如此……以至于\nsuch……that…… ——  如此……以至于\n\n\n条件状语从句\nif\n真实条件：主将从现\n虚假条件：虚拟语气\n\n\nunless=not if ——如果不，除非\nas long as 只要\nas far as +句子\nsb know(s) 据某人所知\nsb be concerned 就……而言\non condition that 条件是\n\n\n\n\n方式状语从句\nas —— 与……一样\nas if，as though —— 仿佛，好像\n\n\n让步状语从句\n连接词为：疑问词+ever=no matter +疑问词\nno matter how + adj/adv + 主+谓\nwhatever+n+主+谓\n\n\nas\n\n\n\n特殊句型倒装句完全倒装：将表示时间或地点的名词放于句首，且主语为人称代词(I/you/he/she/it/we/they)，中间用动词连接\n部分倒装(重点)：\n\n复合谓语半倒装\n情态动词或者助动词放于主语前面，形成一般疑问句式\nHe can do it —— Can he do it\n\n\n独立谓语半倒装\n独立谓语只要一个动词，所以要半倒装的话，需要去借\n原型——do\n三单——dose\n过去式——did\n\n\nHe lives in the city —— Lives he dose in the city\n\n\n\n什么时候使用半倒装\n否定词放于句首\n常考否定词\nnever 从不\nseldom 几乎不\nlittle 几乎没有\nrarely 很少\nscarcely 很少\nScarcely+Had+主语+done……when……did一……就\n\n\nhardly 几乎不\nHardly+Had+主语+done……when……did一……就\n\n\nbarely 几乎不\nnot\nNot only句1but also句2：前倒后不倒\nNot until句1，句2：前倒后不倒\n\n\nno sooner\nno sooner+Had+主语+done……than……did一……就\n\n\nnowhere\nin no case\nin no way\nat no time\non no account\nunder no circumstances\nby no means\nfew\n\n\n\n\nonly+状语放句首\n方式状语\nin this way\nby doing\n\n\n时间状语\nwhen/after/before等引导词\n\n\n\n\nSo+adj/adv……that放句首  \n反复倒装\n题目构成：\n都是由两句话构成，前句为背景句，后句为考察句\n\n\n做题方法：\n背景句是肯定句\nSo+助动词/情态动词/be动词+主语  某某人也是\nSo+主语+助动词 的确如此\n\n\n背景句是否定句\nneither/Nor+助动词/情态动词/be 动词+主语  某某人也不是\n\n\n\n\n注意：背景句和考察句助动词和情态动词、be动词要保持一致\n\n\nAS\nN/adj/adv+as+主+谓  虽然\n\n\n\n强调句It is/was +被强调部分+that+其他\nit is/was not until +被强调部分+that+其他\n被强调部分是人的时候也可以使用who\n被强调句：\n\n主语\n宾语\n状语\n地点状语\n时间状语\n\n\n\n考点解析：\n\nis和was的选择\n被强调部分\n谓语只要独立谓语可以强调\ndo/dose/did+谓语\n\n\n\n\n连词\n\n反义疑问词\n两大原则\n否定相反(前肯后否,前否后肯)\n助动词一致原则(前后助动词保持一致)\n\n\n前面为祈使句\nlet’s型祈使句，后面用shall we\nlet us型祈使句，后面用will you\nDo(动词原型)开头型祈使句，后面既可以用will you 还可以用won‘t you\n祈使句用动词原型\n\n\n前有must have done\n前句谓语为must have done+过去时间，后面用didn’t+主语\n\n前句谓语为must have done且有for+时间段，后面用haven’t+主语或hasn‘t+主语\n\n前句谓语为must have been，后句用wasn’t或weren‘t+主语\n\n\n\n\n\n注意：反义疑问句中出现主从句，反问句一般与主句保持一致，如果主句中的主语是第一人称，且谓语动词是think/believe/suppose/guess时，反问句与从句保持一致\n感叹句what +(a/an)+（adj）+名词+（主）+（谓）\nhow+adj/adv+（主）+（谓）\nhow+形容词+a(an)+名词+(主)+(谓)\n词汇重点关注与语法有联系的词汇\nif\n\n真实条件——主将从现\nwill do+if+do/does\n\n\n非真实条件——虚拟语气\n虚拟语气部分表格\n省略if的情况\n\n\n\n\nas\n\n让步状语从句：N/adj/adv+as+主+谓\n\n定语从句：\n\n放于句首：As\n\n放于句中先行词要被the same或such修饰\n\nas soon as -……就 主将从现\n\nas long as = so long as 只要，条件状语从句\n\nas wella as 和 就远原则\n\nas far as sb/sth be concerned 就……而言\nas far as sb knows 就……所言\n\nas+adj+as 像……一样…… 同级比较\n\n数词+time as +原级+as 倍数的表达\n\nso as to=in order to 为了\n\nas if = as though 好像 虚拟语气\n\nas the economy develops 时间状语从句 随着……\n\nas soon as possible 尽快\n\nas a matter of fact 事实上\n\nas a result 结果\n\nas usual 像往常一样\n\nas well 也=too\n\nsuch as 例如\n\n\n\n\n\nby\n\nby+时间\n+过去——had done\n+将来(will)——will have done\n+now——have/has done\n\n\nby表示被动\n\n\ndifficult\n\nIt is difficult for sb to do\ndifficulty:have difficulty (in) doing\n\n\nhave:\n\n实义动词：有\n\nhave+三餐 吃三餐\nhave——do\nhad——did\nhas——does\n\n\n助动词：现在完成时 have/has done\n\n情态动词：have to do sth 不得不做某事\n\n使役动词：have sb do \n​                    have sth done\n\n\n\n\n熟记固定搭配和句型\nturn\n\nturn out (to be) 结果证明……\nturn down 调低音量/拒绝\nturn on 打开电器或设备\nturn off 关闭电器或设备\nturn up 调高音量/出现\nturn over 翻转\nturn to sb(for help) 求助于某人\nturn in 上交\nin turn轮流\n\n\ntake\n\ntake in 吸收(光线)\ntake up 占据/开始从事某活动\ntake to 喜欢\ntake over 接管\ntake of 脱衣服/飞机起飞\ntake down 记下/写下\ntake on 呈现\ntake……for  granted 想当然\ntake care of 照顾\ntake advantage of 利用\ntake measures/steps/action to do 采取措施\ntake……into consideration/account              把……考虑在内\ntake part in…… 参加\ntake place 发生\ntake responsibility for 为……承担责任\ntake turn to do 轮流做某事\ntake the place of…… 取代\n\n\ncome\n\ncome up with 想出\ncome out 出版\ncome over 拜访\ncome to 苏醒\ncome across 遇到\ncome true 梦想实现\nwhen it comes to…… 当谈论到……\ncome into effect=go into effect  生效\ncome at =attack 袭击\n\n\nagree\n\nagree with \n+sb 同意某人\n+天气/环境 适合/适应(环境/天气)\n\n\nagree to 同意观点、建议或计划\nagree to do 同意做某事\nagree on = agree upon 双方达成一致\n\n\nall\n\nafter all 毕竟\nall in all 总之\nabove all 最重要的是\nall over +地方  遍及\nfirst of all 首先\nnot……at all 一点都不\n\n\nthan\n\nrather than 而不是\nother than 除了\nnothing than 仅仅\nanything than 绝不\nmore than 多于，超过\nwould rather do……than do…… 宁愿做……也不愿\nmore of A than B 与其说是B不如说是A\n\n\nresult\n\nresult in 导致 \nresult from 由……引起\nas a result 结果(单独使用)\nas a result of +n 由于\n\n\nhear\n\nhear of 听说\nhear from 收到……的来信\n\n\nset\n\nset about doing 开始\nset out to do 动身\nset up 建立/设立\nset aside 留出/空出\nset back 推迟=put off = delay\n\n\nlook\n\nlook into 调查\nlook through 检测(文章)\nlook after 照顾\nlook around 四处看\nlook down upon 轻视\nlook like 看起来像\nlook forward to 期待\nlook out 当心 = take care\nlook like 看起来像\n\n\nput\n\nput up with 忍受=stand=bear\nput up 张贴、提出 = put forward=come up with\nput away 收起来、放好\nput off 推迟\nput forward 提出\nput out 扑灭\nput on 穿上 (强调动作)\nput aside 节省\nput down 写下\n\n\nlay\n\nlay off 解雇=dismiss\nlay aside 放一边、攒钱\nlay out展示、陈列\nlay down 放下\n\n\nmake\n\nmake sure 确信\nmake up 化妆，占……比例+%\nmake up for 弥补\nmake up of 组成=be made up of(被动，强调组成的多元性)\nmake out 理解，辨认出\nmake a mistake 犯错\nmake a decision 做决定\nmake friends with 与某人交朋友\nmake progress 取得进步\nmake use of 利用\nmake up one’s mind 下决心\nmake sense 讲得通\nmake a living 谋生\nmake foe+地方：走向\n\n\ngo\n\ngou after 追求\ngo on 继续\ngo up 上升\ngo down 下降\ngo over 复习\ngo through 仔细查看\ngo wrong 出故障、出毛病\ngo against 违反、反对\ngo ahead 向前、前进\n\n\ncut\n\ncut down 砍倒、消减(费用、数目、开支)\ncut in 抢话、打断别人的说话\ncut off 切断\ncut through 开辟道路\ncut up 切碎\n\n\nbreak—broke—broken\n\nbreak out 爆发\nbreak in 打断某人的谈话\nbreak into 破门而入\nbrake off 突然停止讲话\nbreak through 突围，突破\nbreak up 拆散，分裂\nbreak the law 违反法律\nbreak the record 打破记录\nbreak one’s heart 使某人伤心\nbreak the habit of 改掉……的习惯\nbreak down 抛锚\n\n\nbring—brought—brought\n\nbring about 造成\nbring down 使下降\nbring up 养育、教育(常用被动)\nbring forward 提出(计划)\nbring in 引进\nbring…to the end 结束\n\n\nget\n\nget along with=get on with 与…相处\n\nget used to doing=get accustomed to 习惯于\n\nget in touch with 与某人取得联系\nkeep in touch with 与某人保持联系\n\nget into the habit of 养成…的习惯=form the habit of = develop the habit of\nget into the difficulty/trouble 遭遇麻烦 \n\nget riid of 摆脱，处理\n\nget over (疾病中恢复=recover) 克服(overcome)\n\nget to +地方  到达\narrive：+（in+大地方），+(at+小地方)\nreach \n\n\n\nask\n\nask for 要求得到…\nask sb for sth 向某人索要…\nask help from sb 求助于某人\nask after· 问候\nask sb to do 要求某人做某事\n\n\ngive\n\ngive away 泄露(身份或秘密)\ngive in(to)  投降，让步，屈服\ngive off 发(光，热，电，信号)\ngive out 分发\ngive up 放弃\ngive sb a hand 帮某人一把\n\n\ndie\n\ndie of 死于内因 (disease，hunger)\ndie from 死于外因(accident，earthquake)\ndie away (声音，光，热量) 渐渐变弱\ndie out 消失，灭绝\n\n\nkeep\n\nkeep up with 跟上(pace或fashion)\nkeep in touch with 与某人保持联系\nkeep in mind 记住\nkeep sb information 使某人处于被告知状态\nkeep sb from doing 阻止某人做…\nkeep doing 一直做\nkeep one‘s promise 坚守承诺\nkeep on 继续\nkeep +adj 保持\n\n\ndo\n\ndo harm to 对…有害\n\ndo one’s best to do = try one’s best to = spare no effort to do竭尽全力做\n\ndo with 处理解决  常用于what引导的名从\ndeal with 处理解决 常用于how引导的名从\n\nhave something to do with 与…有关\n\nhave nothing to do with 与…无关\n\n\n\ncheck\n\ncheck out 酒店退房\ncheck in 酒店入住\n\n\nleave\n\nleave sb alone  让某人独处\nleave a deep impression on 给某人留下深刻印象\nleave for +地方 前往某地\nleave a message 留言\nask for leave 请假\nleave off 停止\n\n\nconsist\n\nconsist of 由…组成\nconsist in 在于\nconsist with 符合，一致\n\n\nadd\n\nadd…to… 把…添加到…中\nadd up 加起来\nadd up to 总计达到\nadd in 算入，加上\n\n\ncall\n\ncall off 取消\ncall on+人 = come over 拜访某人，号召\ncall at +地方 参观某地\ncall for 需要\ncall up 给某人打电话\n\n\ncarry\n\ncarry out 执行\ncarry away 带走\ncarry back 带回\ncarry on 坚持\n\n\ncatch\n\nbe catch in the rain 被雨淋\nbe caught doing 被抓到…\ncatch fire 着火\ncatch a cold 患感冒\ncatch up with 追上\ncatch on 受欢迎，流行，理解\ncatch sight of 瞥见\ncatch up in 陷入沉思\n\n\nfall\n\nfall sick/ill/asleep/silent 生病，睡着，沉默\nfall behind 落后\nfall in love with 爱上某人\nfall back 撤退\n\n\naccount\n\naccount for 说明(理由)；导致；占(比例)\nan account of = because of=due to = as a result of 由于；因为\non no account 绝不\ntake sth into account = take sth inro consideration 把…考虑在内\n\n\npick\n\npick out 挑选\npick up 捡起来，接受信号，用车接人，学习某种语言或技能\n\n\nsend\n\nsend for 派人去请\nsend away = lay off=dismiss 解雇\nsend sb off = see sb off 为某人送行\nsend out 发射\n\n\nrun\n\nrun across 突然遇到\nrun after 追求\nrun out of 用完\nrun a risk of = at the risk of 冒…的风险\nrun a company 经营一家公司\n\n\nway\n\nby the way 顺便说\n\nin no way 绝不\n\nmake way for 给某人让路\n\nin the way 挡路\nin this way 用这种方法\n\nin a way 在某种程度上，从某一方面\n\n\n\nword\n\nbreak one’s word 不信守诺言\nkeep one’s word 信守诺言\nin other word 换句话说\nin a/one word 简而言之\n\n\n\n动词+介词或副词类短语\n动词+at\naim at 向…瞄准，以…为目标\nrun at 冲向\ncall at 拜访(地点)\nlook at 看\ncome at 袭击\nstare at 凝视\nglance at 瞥一眼\narrive at 到达(小地方)\n\n\n动词+about\ntalk about 谈论\nthink about 思考\ncare about 关心\nbring about 引起，造成\nset about 着手，开始\nworry about 为…担心\n\n\n动词+away\ndie away 逐渐消失\nput away 收起来\ntake away 拿走\ngive away 泄露\nthrow away 扔掉\ncarry away 拿走\n\n\n动词+back\nhold back 控制住\ngive back 归还\ncall back 回电话\nlook back (on) 回顾\n\n\n动词+down\ncut down 砍倒；消减\nput down=take down 记下\nturn down 调低音量，拒绝\npass down 传下来\ncalm down 平静下来\nbreak down 使…降低\nsettle down 安家\n\n\n\n通过构词法掌握近义词、反义词和近形词做题步骤定语从句\n看选项确定考点，选项中有wh已经that时，且空前的单词一定是名词/代词(something)\n\n确定考点后，找题干中有没有固定搭配\n\n若无固定搭配，做题需要分三步走\n\n找从句\n\n看从句是否完整\n\n根据先行词(被修饰名词)选择关系词\n注意：\n​            从句不完整情况下：先行词是物——which、that，人——who，whom\n​            从句完整情况下：时间——when，地点——where，原因——why，whose——翻译为……的\n​            介词+which/whom 一般靠固定搭配 \n\n\n\n\n补充：\n\n插入语，\n\n状语从句when 当……时候，突然\nwhere 在什么地方 \nas ：当……时候，随着，虽然，按照，正如，一边……一边，因为，根据语境选择合适意思\nas翻译成虽然时，必须使用as+N/adj/adv+主谓 = V/adj/adv/n+as+主+谓\nsince：自从，因为，既然\neven if = even though 即使\nnow that 既然\nwhile +doing 当……时候，然而，虽然\nThe instand/minute/second 一……就\nas though = as if ——仿佛，好像\nso that = In order that ——为了\nas well as 也，和……一样\nas far as 直到，就……而言\nso + adj/adv +that = such+n+that 如此……以至于\nlest 以防万一\nunless 除非，如果不\nin case 假如，以防万一\nfor fear that 以免，唯恐\nnot……but……不是而是\nin that 因为\non condition that 条件是\nfor 因为\nnevertheless然而\nas a result 导致，结果是\nthe+比较级+主+谓 越……越……\nbut for 如果没有\nas if 好像\nthe way 像……那样\nit will be  + 一段时间 +before 要过……才……\nnot that …… but that 不是因为……而是因为……\nit wasn’t  long before …… 没过多久就……\nthe instand that 一……就\n名词性从句\n在名词性从句中：只要that引导宾语从句，引导词才可以省略\n主谓一致\nThe+adj/done ——一般表一类人(复苏)\ntwo-third 分数表达法(数词)：\n​    分子用基数词，分母用序数词，分子大于1分母+s\nevery/each+N 做主语，V单\nThey/we each 做主语，V复\nmore than one +N 单数，V单\nmore+M复数+than one，V复\nthe number of +N复/adv复 + V单\nQuantities of+不可数名词/可数名词复数 ，动词用复数\na greatdeal of/a large amount of/a bit of +不可数名词+V单\n通常情况下一句话做主语，V单数，但是，当主句为主系表结构时，位于动词通常有be动词后的名词来决定\n时间、距离、长度、价格、重量做主语永远是单数\n特殊句型选项有陈述语序或疑问语序，就用半倒装\n反义疑问词陈述句部分是Iwe+(don’t) +think/suppose/believe/rxpect/imagine……+宾语从句，第二部分谓语根据从句中的判断\n陈述句部分主语是everyone/someone/anyone/no one/everybody/anybody/nobody,第二部分主语通常为they\n完型填空阅读理解判断题\n\n\n判断为对：\n\n判断为错：\n\n推断题\n\n","slug":"专升本笔记","date":"2020-08-15T10:49:36.000Z","categories_index":"Cate","tags_index":"Tag","author_index":"无言"}]